{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar isIOS = require('../../util/browserdetection').isIOS;\nvar detectSilentAudio = require('../../util/detectsilentaudio');\nvar isIOSChrome = require('../../webrtc/util').isIOSChrome;\nvar AudioTrack = require('./audiotrack');\nvar mixinLocalMediaTrack = require('./localmediatrack');\nvar LocalMediaAudioTrack = mixinLocalMediaTrack(AudioTrack);\n/**\n * A {@link LocalAudioTrack} is an {@link AudioTrack} representing audio that\n * your {@link LocalParticipant} can publish to a {@link Room}. It can be\n * enabled and disabled with {@link LocalAudioTrack#enable} and\n * {@link LocalAudioTrack#disable} or stopped completely with\n * {@link LocalAudioTrack#stop}.\n * @extends AudioTrack\n * @property {Track.ID} id - The {@link LocalAudioTrack}'s ID\n * @property {boolean} isMuted - Whether or not the audio source has stopped sending samples to the\n *   {@link LocalAudioTrack}; This can happen when the microphone is taken over by another application,\n *   mainly on mobile devices; When this property toggles, then <code>muted</code> and <code>unmuted</code>\n *   events are fired appropriately\n * @property {boolean} isStopped - Whether or not the {@link LocalAudioTrack} is\n *   stopped\n * @property {NoiseCancellation?} noiseCancellation - When a LocalAudioTrack is created\n *   with {@link NoiseCancellationOptions}, this property provides interface\n *   to enable or disable the noise cancellation at runtime.\n * @emits LocalAudioTrack#disabled\n * @emits LocalAudioTrack#enabled\n * @emits LocalAudioTrack#muted\n * @emits LocalAudioTrack#started\n * @emits LocalAudioTrack#stopped\n * @emits LocalAudioTrack#unmuted\n */\nvar LocalAudioTrack = /** @class */function (_super) {\n  __extends(LocalAudioTrack, _super);\n  /**\n   * Construct a {@link LocalAudioTrack} from a MediaStreamTrack.\n   * @param {MediaStreamTrack} mediaStreamTrack - An audio MediaStreamTrack\n   * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n   */\n  function LocalAudioTrack(mediaStreamTrack, options) {\n    var _this = this;\n    var noiseCancellation = (options === null || options === void 0 ? void 0 : options.noiseCancellation) || null;\n    _this = _super.call(this, mediaStreamTrack, options) || this;\n    var log = _this._log;\n    var _a = mediaStreamTrack.label,\n      defaultDeviceLabel = _a === void 0 ? '' : _a;\n    var _b = mediaStreamTrack.getSettings(),\n      _c = _b.deviceId,\n      defaultDeviceId = _c === void 0 ? '' : _c,\n      _d = _b.groupId,\n      defaultGroupId = _d === void 0 ? '' : _d;\n    Object.defineProperties(_this, {\n      _currentDefaultDeviceInfo: {\n        value: {\n          deviceId: defaultDeviceId,\n          groupId: defaultGroupId,\n          label: defaultDeviceLabel\n        },\n        writable: true\n      },\n      _enumerateDevices: {\n        value: typeof (options === null || options === void 0 ? void 0 : options.enumerateDevices) === 'function' ? options.enumerateDevices : navigator.mediaDevices.enumerateDevices\n      },\n      _defaultDeviceCaptureMode: {\n        value: (!isIOS() || !!noiseCancellation) && _this._isCreatedByCreateLocalTracks && typeof navigator === 'object' && typeof navigator.mediaDevices === 'object' && typeof navigator.mediaDevices.addEventListener === 'function' && (typeof (options === null || options === void 0 ? void 0 : options.enumerateDevices) === 'function' || typeof navigator.mediaDevices.enumerateDevices === 'function') ? (options === null || options === void 0 ? void 0 : options.defaultDeviceCaptureMode) || 'auto' : 'manual'\n      },\n      _onDeviceChange: {\n        value: function () {\n          _this._enumerateDevices().then(function (deviceInfos) {\n            // NOTE(mmalavalli): In Chrome, when the default device changes, and we restart the LocalAudioTrack with\n            // device ID \"default\", it will not switch to the new default device unless all LocalAudioTracks capturing\n            // from the old default device are stopped. So, we restart the LocalAudioTrack with the actual device ID of\n            // the new default device instead.\n            var defaultDeviceInfo = deviceInfos.find(function (_a) {\n              var deviceId = _a.deviceId,\n                kind = _a.kind;\n              return kind === 'audioinput' && deviceId !== 'default';\n            });\n            if (defaultDeviceInfo && ['deviceId', 'groupId'].some(function (prop) {\n              return defaultDeviceInfo[prop] !== _this._currentDefaultDeviceInfo[prop];\n            })) {\n              log.info('Default device changed, restarting the LocalAudioTrack');\n              log.debug(\"Old default device: \\\"\" + _this._currentDefaultDeviceInfo.deviceId + \"\\\" => \\\"\" + _this._currentDefaultDeviceInfo.label + \"\\\"\");\n              log.debug(\"New default device: \\\"\" + defaultDeviceInfo.deviceId + \"\\\" => \\\"\" + defaultDeviceInfo.label + \"\\\"\");\n              _this._currentDefaultDeviceInfo = defaultDeviceInfo;\n              _this._restartDefaultDevice().catch(function (error) {\n                return log.warn(\"Failed to restart: \" + error.message);\n              });\n            }\n          }, function (error) {\n            log.warn(\"Failed to run enumerateDevices(): \" + error.message);\n          });\n        }\n      },\n      _restartOnDefaultDeviceChangeCleanup: {\n        value: null,\n        writable: true\n      },\n      noiseCancellation: {\n        enumerable: true,\n        value: noiseCancellation,\n        writable: false\n      }\n    });\n    log.debug('defaultDeviceCaptureMode:', _this._defaultDeviceCaptureMode);\n    _this._maybeRestartOnDefaultDeviceChange();\n    return _this;\n  }\n  LocalAudioTrack.prototype.toString = function () {\n    return \"[LocalAudioTrack #\" + this._instanceId + \": \" + this.id + \"]\";\n  };\n  LocalAudioTrack.prototype.attach = function (el) {\n    el = _super.prototype.attach.call(this, el);\n    el.muted = true;\n    return el;\n  };\n  /**\n   * @private\n   */\n  LocalAudioTrack.prototype._end = function () {\n    return _super.prototype._end.apply(this, arguments);\n  };\n  /**\n   * @private\n   */\n  LocalAudioTrack.prototype._maybeRestartOnDefaultDeviceChange = function () {\n    var _this = this;\n    var _a = this,\n      constraints = _a._constraints,\n      defaultDeviceCaptureMode = _a._defaultDeviceCaptureMode,\n      log = _a._log;\n    var mediaStreamTrack = this.noiseCancellation ? this.noiseCancellation.sourceTrack : this.mediaStreamTrack;\n    var deviceId = mediaStreamTrack.getSettings().deviceId;\n    var isNotEqualToCapturedDeviceIdOrEqualToDefault = function (requestedDeviceId) {\n      return requestedDeviceId !== deviceId || requestedDeviceId === 'default';\n    };\n    var isCapturingFromDefaultDevice = function checkIfCapturingFromDefaultDevice(deviceIdConstraint) {\n      if (deviceIdConstraint === void 0) {\n        deviceIdConstraint = {};\n      }\n      if (typeof deviceIdConstraint === 'string') {\n        return isNotEqualToCapturedDeviceIdOrEqualToDefault(deviceIdConstraint);\n      } else if (Array.isArray(deviceIdConstraint)) {\n        return deviceIdConstraint.every(isNotEqualToCapturedDeviceIdOrEqualToDefault);\n      } else if (deviceIdConstraint.exact) {\n        return checkIfCapturingFromDefaultDevice(deviceIdConstraint.exact);\n      } else if (deviceIdConstraint.ideal) {\n        return checkIfCapturingFromDefaultDevice(deviceIdConstraint.ideal);\n      }\n      return true;\n    }(constraints.deviceId);\n    if (defaultDeviceCaptureMode === 'auto' && isCapturingFromDefaultDevice) {\n      if (!this._restartOnDefaultDeviceChangeCleanup) {\n        log.info('LocalAudioTrack will be restarted if the default device changes');\n        navigator.mediaDevices.addEventListener('devicechange', this._onDeviceChange);\n        this._restartOnDefaultDeviceChangeCleanup = function () {\n          log.info('Cleaning up the listener to restart the LocalAudioTrack if the default device changes');\n          navigator.mediaDevices.removeEventListener('devicechange', _this._onDeviceChange);\n          _this._restartOnDefaultDeviceChangeCleanup = null;\n        };\n      }\n    } else {\n      log.info('LocalAudioTrack will NOT be restarted if the default device changes');\n      if (this._restartOnDefaultDeviceChangeCleanup) {\n        this._restartOnDefaultDeviceChangeCleanup();\n      }\n    }\n  };\n  /**\n   * @private\n   */\n  LocalAudioTrack.prototype._reacquireTrack = function (constraints) {\n    var _this = this;\n    this._log.debug('_reacquireTrack: ', constraints);\n    if (this.noiseCancellation) {\n      return this.noiseCancellation.reacquireTrack(function () {\n        return _super.prototype._reacquireTrack.call(_this, constraints);\n      });\n    }\n    return _super.prototype._reacquireTrack.call(this, constraints);\n  };\n  /**\n   * @private\n   */\n  LocalAudioTrack.prototype._restartDefaultDevice = function () {\n    var _this = this;\n    var constraints = Object.assign({}, this._constraints);\n    var restartConstraints = Object.assign({}, constraints, {\n      deviceId: this._currentDefaultDeviceInfo.deviceId\n    });\n    return this.restart(restartConstraints).then(function () {\n      // NOTE(mmalavalli): Since we used the new default device's ID while restarting the LocalAudioTrack,\n      // we reset the constraints to the original constraints so that the default device detection logic in\n      // _maybeRestartOnDefaultDeviceChange() still works.\n      _this._constraints = constraints;\n      _this._maybeRestartOnDefaultDeviceChange();\n    });\n  };\n  /**\n   * NOTE(mmalavalli): On iOS 17 Chrome, a LocalAudioTrack with Krisp Noise Cancellation\n   * enabled that is restarted due to foregrounding the browser is silent for as-of-yet\n   * unknown reason. We work around this by discarding the Krisp MediaStreamTrack and using\n   * the source MediaStreamTrack. (VIDEO-13006)\n   * @private\n   */\n  LocalAudioTrack.prototype._setMediaStreamTrack = function (mediaStreamTrack) {\n    var _this = this;\n    var _a = this,\n      log = _a._log,\n      noiseCancellation = _a.noiseCancellation;\n    var promise = _super.prototype._setMediaStreamTrack.call(this, mediaStreamTrack);\n    if (isIOSChrome() && !!noiseCancellation) {\n      log.debug('iOS Chrome detected, checking if the restarted Krisp audio is silent');\n      promise = promise.then(function () {\n        return detectSilentAudio(_this._dummyEl);\n      }).then(function (isSilent) {\n        log.debug(\"Krisp audio is \" + (isSilent ? 'silent, using source audio' : 'not silent'));\n        return isSilent && noiseCancellation.disablePermanently().then(function () {\n          return _super.prototype._setMediaStreamTrack.call(_this, noiseCancellation.sourceTrack);\n        });\n      });\n    }\n    return promise;\n  };\n  /**\n   * Disable the {@link LocalAudioTrack}. This is equivalent to muting the audio source.\n   * @returns {this}\n   * @fires LocalAudioTrack#disabled\n   */\n  LocalAudioTrack.prototype.disable = function () {\n    return _super.prototype.disable.apply(this, arguments);\n  };\n  /**\n   * Enable the {@link LocalAudioTrack}. This is equivalent to unmuting the audio source.\n   * @returns {this}\n   * @fires LocalAudioTrack#enabled\n  */ /**\n     * Enable or disable the {@link LocalAudioTrack}. This is equivalent to unmuting or muting\n     * the audio source respectively.\n     * @param {boolean} [enabled] - Specify false to disable the\n     *   {@link LocalAudioTrack}\n     * @returns {this}\n     * @fires LocalAudioTrack#disabled\n     * @fires LocalAudioTrack#enabled\n     */\n  LocalAudioTrack.prototype.enable = function () {\n    return _super.prototype.enable.apply(this, arguments);\n  };\n  /**\n   * Restart the {@link LocalAudioTrack}. This stops the existing MediaStreamTrack\n   * and creates a new MediaStreamTrack. If the {@link LocalAudioTrack} is being published\n   * to a {@link Room}, then all the {@link RemoteParticipant}s will start receiving media\n   * from the newly created MediaStreamTrack. You can access the new MediaStreamTrack via\n   * the <code>mediaStreamTrack</code> property. If you want to listen to events on\n   * the MediaStreamTrack directly, please do so in the \"started\" event handler. Also,\n   * the {@link LocalAudioTrack}'s ID is no longer guaranteed to be the same as the\n   * underlying MediaStreamTrack's ID.\n   * @param {MediaTrackConstraints} [constraints] - The optional <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\" target=\"_blank\">MediaTrackConstraints</a>\n   *   for restarting the {@link LocalAudioTrack}; If not specified, then the current MediaTrackConstraints\n   *   will be used; If <code>{}</code> (empty object) is specified, then the default MediaTrackConstraints\n   *   will be used\n   * @returns {Promise<void>} Rejects with a TypeError if the {@link LocalAudioTrack} was not created\n   *   using an one of <code>createLocalAudioTrack</code>, <code>createLocalTracks</code> or <code>connect</code>;\n   *   Also rejects with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Exceptions\" target=\"_blank\">DOMException</a>\n   *   raised by <code>getUserMedia</code> when it fails\n   * @fires LocalAudioTrack#stopped\n   * @fires LocalAudioTrack#started\n   * @example\n   * const { connect, createLocalAudioTrack } = require('twilio-video');\n   *\n   * // Create a LocalAudioTrack that captures audio from a USB microphone.\n   * createLocalAudioTrack({ deviceId: 'usb-mic-id' }).then(function(localAudioTrack) {\n   *   return connect('token', {\n   *     name: 'my-cool-room',\n   *     tracks: [localAudioTrack]\n   *   });\n   * }).then(function(room) {\n   *   // Restart the LocalAudioTrack to capture audio from the default microphone.\n   *   const localAudioTrack = Array.from(room.localParticipant.audioTracks.values())[0].track;\n   *   return localAudioTrack.restart({ deviceId: 'default-mic-id' });\n   * });\n   */\n  LocalAudioTrack.prototype.restart = function () {\n    return _super.prototype.restart.apply(this, arguments);\n  };\n  /**\n   * Calls stop on the underlying MediaStreamTrack. If you choose to stop a\n   * {@link LocalAudioTrack}, you should unpublish it after stopping.\n   * @returns {this}\n   * @fires LocalAudioTrack#stopped\n   */\n  LocalAudioTrack.prototype.stop = function () {\n    if (this.noiseCancellation) {\n      this.noiseCancellation.stop();\n    }\n    if (this._restartOnDefaultDeviceChangeCleanup) {\n      this._restartOnDefaultDeviceChangeCleanup();\n    }\n    return _super.prototype.stop.apply(this, arguments);\n  };\n  return LocalAudioTrack;\n}(LocalMediaAudioTrack);\n/**\n * The {@link LocalAudioTrack} was disabled, i.e. the audio source was muted by the user.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was\n *   disabled\n * @event LocalAudioTrack#disabled\n */\n/**\n * The {@link LocalAudioTrack} was enabled, i.e. the audio source was unmuted by the user.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was enabled\n * @event LocalAudioTrack#enabled\n */\n/**\n * The {@link LocalAudioTrack} was muted because the audio source stopped sending samples, most\n * likely due to another application taking said audio source, especially on mobile devices.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was muted\n * @event LocalAudioTrack#muted\n */\n/**\n * The {@link LocalAudioTrack} started. This means there is enough audio data to\n * begin playback.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that started\n * @event LocalAudioTrack#started\n */\n/**\n * The {@link LocalAudioTrack} stopped, either because {@link LocalAudioTrack#stop}\n * or {@link LocalAudioTrack#restart} was called or because the underlying\n * MediaStreamTrack ended.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that stopped\n * @event LocalAudioTrack#stopped\n */\n/**\n * The {@link LocalAudioTrack} was unmuted because the audio source resumed sending samples,\n * most likely due to the application that took over the said audio source has released it\n * back to the application, especially on mobile devices. This event is also fired when\n * {@link LocalAudioTrack#restart} is called on a muted {@link LocalAudioTrack} with a\n * new audio source.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was unmuted\n * @event LocalAudioTrack#unmuted\n */\nmodule.exports = LocalAudioTrack;","map":{"version":3,"names":["isIOS","require","detectSilentAudio","isIOSChrome","AudioTrack","mixinLocalMediaTrack","LocalMediaAudioTrack","LocalAudioTrack","_super","__extends","mediaStreamTrack","options","_this","noiseCancellation","call","log","_log","_a","label","defaultDeviceLabel","_b","getSettings","_c","deviceId","defaultDeviceId","_d","groupId","defaultGroupId","Object","defineProperties","_currentDefaultDeviceInfo","value","writable","_enumerateDevices","enumerateDevices","navigator","mediaDevices","_defaultDeviceCaptureMode","_isCreatedByCreateLocalTracks","addEventListener","defaultDeviceCaptureMode","_onDeviceChange","then","deviceInfos","defaultDeviceInfo","find","kind","some","prop","info","debug","_restartDefaultDevice","catch","error","warn","message","_restartOnDefaultDeviceChangeCleanup","enumerable","_maybeRestartOnDefaultDeviceChange","prototype","toString","_instanceId","id","attach","el","muted","_end","apply","arguments","constraints","_constraints","sourceTrack","isNotEqualToCapturedDeviceIdOrEqualToDefault","requestedDeviceId","isCapturingFromDefaultDevice","checkIfCapturingFromDefaultDevice","deviceIdConstraint","Array","isArray","every","exact","ideal","removeEventListener","_reacquireTrack","reacquireTrack","assign","restartConstraints","restart","_setMediaStreamTrack","promise","_dummyEl","isSilent","disablePermanently","disable","enable","stop","module","exports"],"sources":["C:\\Users\\gamin\\OneDrive\\Desktop\\Project\\Whiteboard\\live-whiteboard-app\\whiteboard-frontend\\node_modules\\twilio-video\\lib\\media\\track\\localaudiotrack.js"],"sourcesContent":["'use strict';\n\nconst { isIOS } = require('../../util/browserdetection');\nconst detectSilentAudio = require('../../util/detectsilentaudio');\nconst { isIOSChrome } = require('../../webrtc/util');\nconst AudioTrack = require('./audiotrack');\nconst mixinLocalMediaTrack = require('./localmediatrack');\n\nconst LocalMediaAudioTrack = mixinLocalMediaTrack(AudioTrack);\n\n/**\n * A {@link LocalAudioTrack} is an {@link AudioTrack} representing audio that\n * your {@link LocalParticipant} can publish to a {@link Room}. It can be\n * enabled and disabled with {@link LocalAudioTrack#enable} and\n * {@link LocalAudioTrack#disable} or stopped completely with\n * {@link LocalAudioTrack#stop}.\n * @extends AudioTrack\n * @property {Track.ID} id - The {@link LocalAudioTrack}'s ID\n * @property {boolean} isMuted - Whether or not the audio source has stopped sending samples to the\n *   {@link LocalAudioTrack}; This can happen when the microphone is taken over by another application,\n *   mainly on mobile devices; When this property toggles, then <code>muted</code> and <code>unmuted</code>\n *   events are fired appropriately\n * @property {boolean} isStopped - Whether or not the {@link LocalAudioTrack} is\n *   stopped\n * @property {NoiseCancellation?} noiseCancellation - When a LocalAudioTrack is created\n *   with {@link NoiseCancellationOptions}, this property provides interface\n *   to enable or disable the noise cancellation at runtime.\n * @emits LocalAudioTrack#disabled\n * @emits LocalAudioTrack#enabled\n * @emits LocalAudioTrack#muted\n * @emits LocalAudioTrack#started\n * @emits LocalAudioTrack#stopped\n * @emits LocalAudioTrack#unmuted\n */\nclass LocalAudioTrack extends LocalMediaAudioTrack {\n  /**\n   * Construct a {@link LocalAudioTrack} from a MediaStreamTrack.\n   * @param {MediaStreamTrack} mediaStreamTrack - An audio MediaStreamTrack\n   * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n   */\n  constructor(mediaStreamTrack, options) {\n    const noiseCancellation = options?.noiseCancellation || null;\n    super(mediaStreamTrack, options);\n\n    const { _log: log } = this;\n    const { label: defaultDeviceLabel = '' } = mediaStreamTrack;\n    const { deviceId: defaultDeviceId = '', groupId: defaultGroupId = '' } = mediaStreamTrack.getSettings();\n\n    Object.defineProperties(this, {\n      _currentDefaultDeviceInfo: {\n        value: { deviceId: defaultDeviceId, groupId: defaultGroupId, label: defaultDeviceLabel },\n        writable: true\n      },\n      _enumerateDevices: {\n        value: typeof options?.enumerateDevices === 'function'\n          ? options.enumerateDevices\n          : navigator.mediaDevices.enumerateDevices\n      },\n      _defaultDeviceCaptureMode: {\n        value: (!isIOS() || !!noiseCancellation)\n          && this._isCreatedByCreateLocalTracks\n          && typeof navigator === 'object'\n          && typeof navigator.mediaDevices === 'object'\n          && typeof navigator.mediaDevices.addEventListener === 'function'\n          && (typeof options?.enumerateDevices === 'function' || typeof navigator.mediaDevices.enumerateDevices === 'function')\n          ? options?.defaultDeviceCaptureMode || 'auto'\n          : 'manual'\n      },\n      _onDeviceChange: {\n        value: () => {\n          this._enumerateDevices().then(deviceInfos => {\n            // NOTE(mmalavalli): In Chrome, when the default device changes, and we restart the LocalAudioTrack with\n            // device ID \"default\", it will not switch to the new default device unless all LocalAudioTracks capturing\n            // from the old default device are stopped. So, we restart the LocalAudioTrack with the actual device ID of\n            // the new default device instead.\n            const defaultDeviceInfo = deviceInfos.find(({ deviceId, kind }) => {\n              return kind === 'audioinput' && deviceId !== 'default';\n            });\n\n            if (defaultDeviceInfo && ['deviceId', 'groupId'].some(prop => {\n              return defaultDeviceInfo[prop] !== this._currentDefaultDeviceInfo[prop];\n            })) {\n              log.info('Default device changed, restarting the LocalAudioTrack');\n              log.debug(`Old default device: \"${this._currentDefaultDeviceInfo.deviceId}\" => \"${this._currentDefaultDeviceInfo.label}\"`);\n              log.debug(`New default device: \"${defaultDeviceInfo.deviceId}\" => \"${defaultDeviceInfo.label}\"`);\n              this._currentDefaultDeviceInfo = defaultDeviceInfo;\n              this._restartDefaultDevice().catch(error => log.warn(`Failed to restart: ${error.message}`));\n            }\n          }, error => {\n            log.warn(`Failed to run enumerateDevices(): ${error.message}`);\n          });\n        }\n      },\n      _restartOnDefaultDeviceChangeCleanup: {\n        value: null,\n        writable: true\n      },\n      noiseCancellation: {\n        enumerable: true,\n        value: noiseCancellation,\n        writable: false\n      },\n    });\n\n    log.debug('defaultDeviceCaptureMode:', this._defaultDeviceCaptureMode);\n    this._maybeRestartOnDefaultDeviceChange();\n  }\n\n  toString() {\n    return `[LocalAudioTrack #${this._instanceId}: ${this.id}]`;\n  }\n\n  attach(el) {\n    el = super.attach.call(this, el);\n    el.muted = true;\n    return el;\n  }\n\n  /**\n   * @private\n   */\n  _end() {\n    return super._end.apply(this, arguments);\n  }\n\n  /**\n   * @private\n   */\n  _maybeRestartOnDefaultDeviceChange() {\n    const { _constraints: constraints, _defaultDeviceCaptureMode: defaultDeviceCaptureMode, _log: log } = this;\n    const mediaStreamTrack = this.noiseCancellation ? this.noiseCancellation.sourceTrack : this.mediaStreamTrack;\n    const { deviceId } = mediaStreamTrack.getSettings();\n\n    const isNotEqualToCapturedDeviceIdOrEqualToDefault = requestedDeviceId => {\n      return requestedDeviceId !== deviceId || requestedDeviceId === 'default';\n    };\n\n    const isCapturingFromDefaultDevice = (function checkIfCapturingFromDefaultDevice(deviceIdConstraint = {}) {\n      if (typeof deviceIdConstraint === 'string') {\n        return isNotEqualToCapturedDeviceIdOrEqualToDefault(deviceIdConstraint);\n      } else if (Array.isArray(deviceIdConstraint)) {\n        return deviceIdConstraint.every(isNotEqualToCapturedDeviceIdOrEqualToDefault);\n      } else if (deviceIdConstraint.exact) {\n        return checkIfCapturingFromDefaultDevice(deviceIdConstraint.exact);\n      } else if (deviceIdConstraint.ideal) {\n        return checkIfCapturingFromDefaultDevice(deviceIdConstraint.ideal);\n      }\n      return true;\n    }(constraints.deviceId));\n\n    if (defaultDeviceCaptureMode === 'auto' && isCapturingFromDefaultDevice) {\n      if (!this._restartOnDefaultDeviceChangeCleanup) {\n        log.info('LocalAudioTrack will be restarted if the default device changes');\n        navigator.mediaDevices.addEventListener('devicechange', this._onDeviceChange);\n        this._restartOnDefaultDeviceChangeCleanup = () => {\n          log.info('Cleaning up the listener to restart the LocalAudioTrack if the default device changes');\n          navigator.mediaDevices.removeEventListener('devicechange', this._onDeviceChange);\n          this._restartOnDefaultDeviceChangeCleanup = null;\n        };\n      }\n    } else {\n      log.info('LocalAudioTrack will NOT be restarted if the default device changes');\n      if (this._restartOnDefaultDeviceChangeCleanup) {\n        this._restartOnDefaultDeviceChangeCleanup();\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  _reacquireTrack(constraints) {\n    this._log.debug('_reacquireTrack: ', constraints);\n    if (this.noiseCancellation) {\n      return this.noiseCancellation.reacquireTrack(() => {\n        return super._reacquireTrack.call(this, constraints);\n      });\n    }\n\n    return super._reacquireTrack.call(this, constraints);\n  }\n\n  /**\n   * @private\n   */\n  _restartDefaultDevice() {\n    const constraints = Object.assign({}, this._constraints);\n    const restartConstraints = Object.assign({}, constraints, { deviceId: this._currentDefaultDeviceInfo.deviceId });\n    return this.restart(restartConstraints).then(() => {\n      // NOTE(mmalavalli): Since we used the new default device's ID while restarting the LocalAudioTrack,\n      // we reset the constraints to the original constraints so that the default device detection logic in\n      // _maybeRestartOnDefaultDeviceChange() still works.\n      this._constraints = constraints;\n      this._maybeRestartOnDefaultDeviceChange();\n    });\n  }\n\n  /**\n   * NOTE(mmalavalli): On iOS 17 Chrome, a LocalAudioTrack with Krisp Noise Cancellation\n   * enabled that is restarted due to foregrounding the browser is silent for as-of-yet\n   * unknown reason. We work around this by discarding the Krisp MediaStreamTrack and using\n   * the source MediaStreamTrack. (VIDEO-13006)\n   * @private\n   */\n  _setMediaStreamTrack(mediaStreamTrack) {\n    const { _log: log, noiseCancellation } = this;\n    let promise = super._setMediaStreamTrack.call(this, mediaStreamTrack);\n\n    if (isIOSChrome() && !!noiseCancellation) {\n      log.debug('iOS Chrome detected, checking if the restarted Krisp audio is silent');\n      promise = promise.then(() => detectSilentAudio(this._dummyEl)).then(isSilent => {\n        log.debug(`Krisp audio is ${isSilent ? 'silent, using source audio' : 'not silent'}`);\n        return isSilent && noiseCancellation.disablePermanently().then(() => {\n          return super._setMediaStreamTrack.call(this, noiseCancellation.sourceTrack);\n        });\n      });\n    }\n\n    return promise;\n  }\n\n  /**\n   * Disable the {@link LocalAudioTrack}. This is equivalent to muting the audio source.\n   * @returns {this}\n   * @fires LocalAudioTrack#disabled\n   */\n  disable() {\n    return super.disable.apply(this, arguments);\n  }\n\n  /**\n   * Enable the {@link LocalAudioTrack}. This is equivalent to unmuting the audio source.\n   * @returns {this}\n   * @fires LocalAudioTrack#enabled\n  *//**\n   * Enable or disable the {@link LocalAudioTrack}. This is equivalent to unmuting or muting\n   * the audio source respectively.\n   * @param {boolean} [enabled] - Specify false to disable the\n   *   {@link LocalAudioTrack}\n   * @returns {this}\n   * @fires LocalAudioTrack#disabled\n   * @fires LocalAudioTrack#enabled\n   */\n  enable() {\n    return super.enable.apply(this, arguments);\n  }\n\n  /**\n   * Restart the {@link LocalAudioTrack}. This stops the existing MediaStreamTrack\n   * and creates a new MediaStreamTrack. If the {@link LocalAudioTrack} is being published\n   * to a {@link Room}, then all the {@link RemoteParticipant}s will start receiving media\n   * from the newly created MediaStreamTrack. You can access the new MediaStreamTrack via\n   * the <code>mediaStreamTrack</code> property. If you want to listen to events on\n   * the MediaStreamTrack directly, please do so in the \"started\" event handler. Also,\n   * the {@link LocalAudioTrack}'s ID is no longer guaranteed to be the same as the\n   * underlying MediaStreamTrack's ID.\n   * @param {MediaTrackConstraints} [constraints] - The optional <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\" target=\"_blank\">MediaTrackConstraints</a>\n   *   for restarting the {@link LocalAudioTrack}; If not specified, then the current MediaTrackConstraints\n   *   will be used; If <code>{}</code> (empty object) is specified, then the default MediaTrackConstraints\n   *   will be used\n   * @returns {Promise<void>} Rejects with a TypeError if the {@link LocalAudioTrack} was not created\n   *   using an one of <code>createLocalAudioTrack</code>, <code>createLocalTracks</code> or <code>connect</code>;\n   *   Also rejects with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#Exceptions\" target=\"_blank\">DOMException</a>\n   *   raised by <code>getUserMedia</code> when it fails\n   * @fires LocalAudioTrack#stopped\n   * @fires LocalAudioTrack#started\n   * @example\n   * const { connect, createLocalAudioTrack } = require('twilio-video');\n   *\n   * // Create a LocalAudioTrack that captures audio from a USB microphone.\n   * createLocalAudioTrack({ deviceId: 'usb-mic-id' }).then(function(localAudioTrack) {\n   *   return connect('token', {\n   *     name: 'my-cool-room',\n   *     tracks: [localAudioTrack]\n   *   });\n   * }).then(function(room) {\n   *   // Restart the LocalAudioTrack to capture audio from the default microphone.\n   *   const localAudioTrack = Array.from(room.localParticipant.audioTracks.values())[0].track;\n   *   return localAudioTrack.restart({ deviceId: 'default-mic-id' });\n   * });\n   */\n  restart() {\n    return super.restart.apply(this, arguments);\n  }\n\n  /**\n   * Calls stop on the underlying MediaStreamTrack. If you choose to stop a\n   * {@link LocalAudioTrack}, you should unpublish it after stopping.\n   * @returns {this}\n   * @fires LocalAudioTrack#stopped\n   */\n  stop() {\n    if (this.noiseCancellation) {\n      this.noiseCancellation.stop();\n    }\n    if (this._restartOnDefaultDeviceChangeCleanup) {\n      this._restartOnDefaultDeviceChangeCleanup();\n    }\n    return super.stop.apply(this, arguments);\n  }\n}\n\n/**\n * The {@link LocalAudioTrack} was disabled, i.e. the audio source was muted by the user.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was\n *   disabled\n * @event LocalAudioTrack#disabled\n */\n\n/**\n * The {@link LocalAudioTrack} was enabled, i.e. the audio source was unmuted by the user.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was enabled\n * @event LocalAudioTrack#enabled\n */\n\n/**\n * The {@link LocalAudioTrack} was muted because the audio source stopped sending samples, most\n * likely due to another application taking said audio source, especially on mobile devices.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was muted\n * @event LocalAudioTrack#muted\n */\n\n/**\n * The {@link LocalAudioTrack} started. This means there is enough audio data to\n * begin playback.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that started\n * @event LocalAudioTrack#started\n */\n\n/**\n * The {@link LocalAudioTrack} stopped, either because {@link LocalAudioTrack#stop}\n * or {@link LocalAudioTrack#restart} was called or because the underlying\n * MediaStreamTrack ended.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that stopped\n * @event LocalAudioTrack#stopped\n */\n\n/**\n * The {@link LocalAudioTrack} was unmuted because the audio source resumed sending samples,\n * most likely due to the application that took over the said audio source has released it\n * back to the application, especially on mobile devices. This event is also fired when\n * {@link LocalAudioTrack#restart} is called on a muted {@link LocalAudioTrack} with a\n * new audio source.\n * @param {LocalAudioTrack} track - The {@link LocalAudioTrack} that was unmuted\n * @event LocalAudioTrack#unmuted\n */\n\nmodule.exports = LocalAudioTrack;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}