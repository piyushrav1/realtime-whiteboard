{"ast":null,"code":"'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar isIOS = require('../../util/browserdetection').isIOS;\nvar MediaStream = require('../../webrtc').MediaStream;\nvar _a = require('../../util'),\n  waitForEvent = _a.waitForEvent,\n  waitForSometime = _a.waitForSometime;\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nvar Track = require('./');\n/**\n * A {@link MediaTrack} represents audio or video that can be sent to or\n * received from a {@link Room}.\n * @extends Track\n * @property {Track.ID} id - This {@link Track}'s ID\n * @property {boolean} isStarted - Whether or not the {@link MediaTrack} has\n *   started\n * @property {boolean} isEnabled - Whether or not the {@link MediaTrack} is\n *   enabled (i.e., whether it is paused or muted)\n * @property {Track.Kind} kind - The kind of the underlying\n *   MediaStreamTrack, \"audio\" or \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - The underlying\n *   MediaStreamTrack\n * @emits MediaTrack#disabled\n * @emits MediaTrack#enabled\n * @emits MediaTrack#started\n */\nvar MediaTrack = /** @class */function (_super) {\n  __extends(MediaTrack, _super);\n  /**\n   * Construct a {@link MediaTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n  function MediaTrack(mediaTrackTransceiver, options) {\n    var _this = this;\n    options = Object.assign({\n      playPausedElementsIfNotBackgrounded: isIOS() && typeof document === 'object' && typeof document.addEventListener === 'function' && typeof document.visibilityState === 'string'\n    }, options);\n    _this = _super.call(this, mediaTrackTransceiver.id, mediaTrackTransceiver.kind, options) || this;\n    var isStarted = false;\n    options = Object.assign({\n      MediaStream: MediaStream\n    }, options);\n    if (typeof options.MediaStream !== 'function') {\n      throw new Error('MediaTrack received an invalid MediaStream constructor: ' + options.MediaStream);\n    }\n    /* istanbul ignore next */\n    Object.defineProperties(_this, {\n      _attachments: {\n        value: new Set()\n      },\n      _dummyEl: {\n        value: null,\n        writable: true\n      },\n      _elShims: {\n        value: new WeakMap()\n      },\n      _isStarted: {\n        get: function () {\n          return isStarted;\n        },\n        set: function (_isStarted) {\n          isStarted = _isStarted;\n        }\n      },\n      _playPausedElementsIfNotBackgrounded: {\n        value: options.playPausedElementsIfNotBackgrounded\n      },\n      _shouldShimAttachedElements: {\n        value: options.workaroundWebKitBug212780 || options.playPausedElementsIfNotBackgrounded\n      },\n      _unprocessedTrack: {\n        value: null,\n        writable: true\n      },\n      _MediaStream: {\n        value: options.MediaStream\n      },\n      _mapMediaElement: {\n        value: options.mapMediaElement\n      },\n      _disposeMediaElement: {\n        value: options.disposeMediaElement\n      },\n      isStarted: {\n        enumerable: true,\n        get: function () {\n          return isStarted;\n        }\n      },\n      mediaStreamTrack: {\n        enumerable: true,\n        get: function () {\n          return this._unprocessedTrack || mediaTrackTransceiver.track;\n        }\n      },\n      processedTrack: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n    _this._initialize();\n    return _this;\n  }\n  /**\n   * @private\n   */\n  MediaTrack.prototype._start = function () {\n    this._log.debug('Started');\n    this._isStarted = true;\n    if (this._dummyEl) {\n      this._dummyEl.oncanplay = null;\n    }\n    // eslint-disable-next-line no-use-before-define\n    this.emit('started', this);\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._initialize = function () {\n    var self = this;\n    this._log.debug('Initializing');\n    this._dummyEl = this._createElement();\n    if (this.mediaStreamTrack && this.mediaStreamTrack.addEventListener) {\n      this.mediaStreamTrack.addEventListener('ended', function onended() {\n        self._end();\n        self.mediaStreamTrack.removeEventListener('ended', onended);\n      });\n    } else if (this.mediaStreamTrack) {\n      this.mediaStreamTrack.onended = function onended() {\n        self._end();\n        self.mediaStreamTrack.onended = null;\n      };\n    }\n    if (this._dummyEl) {\n      this._dummyEl.muted = true;\n      this._dummyEl.oncanplay = this._start.bind(this, this._dummyEl);\n      // NOTE(csantos): We always want to attach the original mediaStreamTrack for dummyEl\n      this._attach(this._dummyEl, this.mediaStreamTrack);\n      this._attachments.delete(this._dummyEl);\n    }\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._end = function () {\n    this._log.debug('Ended');\n    if (this._dummyEl) {\n      this._dummyEl.remove();\n      if (this._disposeMediaElement) {\n        this._disposeMediaElement(this._dummyEl);\n      } else {\n        this._dummyEl.srcObject = null;\n      }\n      this._dummyEl.oncanplay = null;\n      this._dummyEl = null;\n    }\n  };\n  MediaTrack.prototype.attach = function (el) {\n    var _this = this;\n    if (typeof el === 'string') {\n      el = this._selectElement(el);\n    } else if (!el) {\n      el = this._createElement();\n    }\n    this._log.debug('Attempting to attach to element:', el);\n    el = this._attach(el);\n    if (this._shouldShimAttachedElements && !this._elShims.has(el)) {\n      var onUnintentionallyPaused = this._playPausedElementsIfNotBackgrounded ? function () {\n        return playIfPausedAndNotBackgrounded(el, _this._log);\n      } : null;\n      this._elShims.set(el, shimMediaElement(el, onUnintentionallyPaused));\n    }\n    return el;\n  };\n  /**\n   * Attach the provided MediaStreamTrack to the media element.\n   * @param el - The media element to attach to\n   * @param mediaStreamTrack - The MediaStreamTrack to attach. If this is\n   * not provided, it uses the processedTrack if it exists\n   * or it defaults to the current mediaStreamTrack\n   * @private\n   */\n  MediaTrack.prototype._attach = function (el, mediaStreamTrack) {\n    if (mediaStreamTrack === void 0) {\n      mediaStreamTrack = this.processedTrack || this.mediaStreamTrack;\n    }\n    var mediaStream = el.srcObject;\n    if (!(mediaStream instanceof this._MediaStream)) {\n      mediaStream = new this._MediaStream();\n    }\n    var getTracks = mediaStreamTrack.kind === 'audio' ? 'getAudioTracks' : 'getVideoTracks';\n    mediaStream[getTracks]().forEach(function (track) {\n      mediaStream.removeTrack(track);\n    });\n    mediaStream.addTrack(mediaStreamTrack);\n    // Map the element if a custom mapping function is provided\n    if (this._mapMediaElement) {\n      this._log.debug('Mapping element using mapMediaElement before attaching media to element');\n      this._mapMediaElement(el);\n    }\n    // NOTE(mpatwardhan): resetting `srcObject` here, causes flicker (JSDK-2641), but it lets us\n    // to sidestep the a chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1052353\n    el.srcObject = mediaStream;\n    el.autoplay = true;\n    el.playsInline = true;\n    if (!this._attachments.has(el)) {\n      this._attachments.add(el);\n    }\n    return el;\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._selectElement = function (selector) {\n    var el = document.querySelector(selector);\n    if (!el) {\n      throw new Error(\"Selector matched no element: \" + selector);\n    }\n    return el;\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._updateElementsMediaStreamTrack = function () {\n    var _this = this;\n    this._log.debug('Reattaching all elements to update mediaStreamTrack');\n    this._getAllAttachedElements().forEach(function (el) {\n      return _this._attach(el);\n    });\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._createElement = function () {\n    return typeof document !== 'undefined' ? document.createElement(this.kind) : null;\n  };\n  MediaTrack.prototype.detach = function (el) {\n    var els;\n    if (typeof el === 'string') {\n      els = [this._selectElement(el)];\n    } else if (!el) {\n      els = this._getAllAttachedElements();\n    } else {\n      els = [el];\n    }\n    this._log.debug('Attempting to detach from elements:', els);\n    this._detachElements(els);\n    return el ? els[0] : els;\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._detachElements = function (elements) {\n    return elements.map(this._detachElement.bind(this));\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._detachElement = function (el) {\n    if (!this._attachments.has(el)) {\n      return el;\n    }\n    var mediaStream = el.srcObject;\n    if (mediaStream instanceof this._MediaStream) {\n      mediaStream.removeTrack(this.processedTrack || this.mediaStreamTrack);\n    }\n    if (this._disposeMediaElement) {\n      this._log.debug('Disposing element using disposeMediaElement after removing media from element');\n      this._disposeMediaElement(el);\n    }\n    this._attachments.delete(el);\n    if (this._shouldShimAttachedElements && this._elShims.has(el)) {\n      var shim = this._elShims.get(el);\n      shim.unShim();\n      this._elShims.delete(el);\n    }\n    return el;\n  };\n  /**\n   * @private\n   */\n  MediaTrack.prototype._getAllAttachedElements = function () {\n    var els = [];\n    this._attachments.forEach(function (el) {\n      els.push(el);\n    });\n    return els;\n  };\n  return MediaTrack;\n}(Track);\n/**\n * Play an HTMLMediaElement if it is paused and not backgrounded.\n * @private\n * @param {HTMLMediaElement} el\n * @param {Log} log\n * @returns {void}\n */\nfunction playIfPausedAndNotBackgrounded(el, log) {\n  var tag = el.tagName.toLowerCase();\n  log.warn('Unintentionally paused:', el);\n  // NOTE(mmalavalli): When the element is unintentionally paused, we wait one\n  // second for the \"onvisibilitychange\" event on the HTMLDocument to see if the\n  // app will be backgrounded. If not, then the element can be safely played.\n  Promise.race([waitForEvent(document, 'visibilitychange'), waitForSometime(1000)]).then(function () {\n    if (document.visibilityState === 'visible') {\n      // NOTE(mmalavalli): We play the inadvertently paused elements only after\n      // the LocalAudioTrack is unmuted to work around WebKit Bug 213853.\n      //\n      // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n      //\n      localMediaRestartDeferreds.whenResolved('audio').then(function () {\n        log.info(\"Playing unintentionally paused <\" + tag + \"> element\");\n        log.debug('Element:', el);\n        return el.play();\n      }).then(function () {\n        log.info(\"Successfully played unintentionally paused <\" + tag + \"> element\");\n        log.debug('Element:', el);\n      }).catch(function (error) {\n        log.warn(\"Error while playing unintentionally paused <\" + tag + \"> element:\", {\n          error: error,\n          el: el\n        });\n      });\n    }\n  });\n}\n/**\n * Shim the pause() and play() methods of the given HTMLMediaElement so that\n * we can detect if it was paused unintentionally.\n * @param {HTMLMediaElement} el\n * @param {?function} [onUnintentionallyPaused=null]\n * @returns {{pausedIntentionally: function, unShim: function}}\n */\nfunction shimMediaElement(el, onUnintentionallyPaused) {\n  if (onUnintentionallyPaused === void 0) {\n    onUnintentionallyPaused = null;\n  }\n  var origPause = el.pause;\n  var origPlay = el.play;\n  var pausedIntentionally = false;\n  el.pause = function () {\n    pausedIntentionally = true;\n    return origPause.call(el);\n  };\n  el.play = function () {\n    pausedIntentionally = false;\n    return origPlay.call(el);\n  };\n  var onPause = onUnintentionallyPaused ? function () {\n    if (!pausedIntentionally) {\n      onUnintentionallyPaused();\n    }\n  } : null;\n  if (onPause) {\n    el.addEventListener('pause', onPause);\n  }\n  return {\n    pausedIntentionally: function () {\n      return pausedIntentionally;\n    },\n    unShim: function () {\n      el.pause = origPause;\n      el.play = origPlay;\n      if (onPause) {\n        el.removeEventListener('pause', onPause);\n      }\n    }\n  };\n}\nmodule.exports = MediaTrack;","map":{"version":3,"names":["isIOS","require","MediaStream","_a","waitForEvent","waitForSometime","localMediaRestartDeferreds","Track","MediaTrack","_super","__extends","mediaTrackTransceiver","options","_this","Object","assign","playPausedElementsIfNotBackgrounded","document","addEventListener","visibilityState","call","id","kind","isStarted","Error","defineProperties","_attachments","value","Set","_dummyEl","writable","_elShims","WeakMap","_isStarted","get","set","_playPausedElementsIfNotBackgrounded","_shouldShimAttachedElements","workaroundWebKitBug212780","_unprocessedTrack","_MediaStream","_mapMediaElement","mapMediaElement","_disposeMediaElement","disposeMediaElement","enumerable","mediaStreamTrack","track","processedTrack","_initialize","prototype","_start","_log","debug","oncanplay","emit","self","_createElement","onended","_end","removeEventListener","muted","bind","_attach","delete","remove","srcObject","attach","el","_selectElement","has","onUnintentionallyPaused","playIfPausedAndNotBackgrounded","shimMediaElement","mediaStream","getTracks","forEach","removeTrack","addTrack","autoplay","playsInline","add","selector","querySelector","_updateElementsMediaStreamTrack","_getAllAttachedElements","createElement","detach","els","_detachElements","elements","map","_detachElement","shim","unShim","push","log","tag","tagName","toLowerCase","warn","Promise","race","then","whenResolved","info","play","catch","error","origPause","pause","origPlay","pausedIntentionally","onPause","module","exports"],"sources":["C:\\Users\\gamin\\OneDrive\\Desktop\\Project\\Whiteboard\\live-whiteboard-app\\whiteboard-frontend\\node_modules\\twilio-video\\lib\\media\\track\\mediatrack.js"],"sourcesContent":["'use strict';\n\nconst { isIOS } = require('../../util/browserdetection');\nconst { MediaStream } = require('../../webrtc');\n\nconst { waitForEvent, waitForSometime } = require('../../util');\nconst localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nconst Track = require('./');\n\n/**\n * A {@link MediaTrack} represents audio or video that can be sent to or\n * received from a {@link Room}.\n * @extends Track\n * @property {Track.ID} id - This {@link Track}'s ID\n * @property {boolean} isStarted - Whether or not the {@link MediaTrack} has\n *   started\n * @property {boolean} isEnabled - Whether or not the {@link MediaTrack} is\n *   enabled (i.e., whether it is paused or muted)\n * @property {Track.Kind} kind - The kind of the underlying\n *   MediaStreamTrack, \"audio\" or \"video\"\n * @property {MediaStreamTrack} mediaStreamTrack - The underlying\n *   MediaStreamTrack\n * @emits MediaTrack#disabled\n * @emits MediaTrack#enabled\n * @emits MediaTrack#started\n */\nclass MediaTrack extends Track {\n  /**\n   * Construct a {@link MediaTrack}.\n   * @param {MediaTrackTransceiver} mediaTrackTransceiver\n   * @param {{log: Log}} options\n   */\n  constructor(mediaTrackTransceiver, options) {\n    options = Object.assign({\n      playPausedElementsIfNotBackgrounded: isIOS()\n        && typeof document === 'object'\n        && typeof document.addEventListener === 'function'\n        && typeof document.visibilityState === 'string'\n    }, options);\n\n    super(mediaTrackTransceiver.id, mediaTrackTransceiver.kind, options);\n    let isStarted = false;\n\n    options = Object.assign({\n      MediaStream\n    }, options);\n\n    if (typeof options.MediaStream !== 'function') {\n      throw new Error('MediaTrack received an invalid MediaStream constructor: ' + options.MediaStream);\n    }\n\n    /* istanbul ignore next */\n    Object.defineProperties(this, {\n      _attachments: {\n        value: new Set()\n      },\n      _dummyEl: {\n        value: null,\n        writable: true\n      },\n      _elShims: {\n        value: new WeakMap()\n      },\n      _isStarted: {\n        get() {\n          return isStarted;\n        },\n        set(_isStarted) {\n          isStarted = _isStarted;\n        }\n      },\n      _playPausedElementsIfNotBackgrounded: {\n        value: options.playPausedElementsIfNotBackgrounded\n      },\n      _shouldShimAttachedElements: {\n        value: options.workaroundWebKitBug212780\n          || options.playPausedElementsIfNotBackgrounded\n      },\n      _unprocessedTrack: {\n        value: null,\n        writable: true\n      },\n      _MediaStream: {\n        value: options.MediaStream\n      },\n      _mapMediaElement: {\n        value: options.mapMediaElement\n      },\n      _disposeMediaElement: {\n        value: options.disposeMediaElement\n      },\n      isStarted: {\n        enumerable: true,\n        get() {\n          return isStarted;\n        }\n      },\n      mediaStreamTrack: {\n        enumerable: true,\n        get() {\n          return this._unprocessedTrack || mediaTrackTransceiver.track;\n        }\n      },\n      processedTrack: {\n        enumerable: true,\n        value: null,\n        writable: true\n      }\n    });\n\n    this._initialize();\n  }\n\n  /**\n   * @private\n   */\n  _start() {\n    this._log.debug('Started');\n    this._isStarted = true;\n    if (this._dummyEl) {\n      this._dummyEl.oncanplay = null;\n    }\n    // eslint-disable-next-line no-use-before-define\n    this.emit('started', this);\n  }\n\n  /**\n   * @private\n   */\n  _initialize() {\n    const self = this;\n\n    this._log.debug('Initializing');\n    this._dummyEl = this._createElement();\n\n    if (this.mediaStreamTrack && this.mediaStreamTrack.addEventListener) {\n      this.mediaStreamTrack.addEventListener('ended', function onended() {\n        self._end();\n        self.mediaStreamTrack.removeEventListener('ended', onended);\n      });\n    } else if (this.mediaStreamTrack) {\n      this.mediaStreamTrack.onended = function onended() {\n        self._end();\n        self.mediaStreamTrack.onended = null;\n      };\n    }\n\n    if (this._dummyEl) {\n      this._dummyEl.muted = true;\n      this._dummyEl.oncanplay = this._start.bind(this, this._dummyEl);\n\n      // NOTE(csantos): We always want to attach the original mediaStreamTrack for dummyEl\n      this._attach(this._dummyEl, this.mediaStreamTrack);\n\n      this._attachments.delete(this._dummyEl);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _end() {\n    this._log.debug('Ended');\n    if (this._dummyEl) {\n      this._dummyEl.remove();\n      if (this._disposeMediaElement) {\n        this._disposeMediaElement(this._dummyEl);\n      } else {\n        this._dummyEl.srcObject = null;\n      }\n      this._dummyEl.oncanplay = null;\n      this._dummyEl = null;\n    }\n  }\n\n  attach(el) {\n    if (typeof el === 'string') {\n      el = this._selectElement(el);\n    } else if (!el) {\n      el = this._createElement();\n    }\n    this._log.debug('Attempting to attach to element:', el);\n    el = this._attach(el);\n\n    if (this._shouldShimAttachedElements && !this._elShims.has(el)) {\n      const onUnintentionallyPaused = this._playPausedElementsIfNotBackgrounded\n        ? () => playIfPausedAndNotBackgrounded(el, this._log)\n        : null;\n      this._elShims.set(el, shimMediaElement(el, onUnintentionallyPaused));\n    }\n    return el;\n  }\n\n  /**\n   * Attach the provided MediaStreamTrack to the media element.\n   * @param el - The media element to attach to\n   * @param mediaStreamTrack - The MediaStreamTrack to attach. If this is\n   * not provided, it uses the processedTrack if it exists\n   * or it defaults to the current mediaStreamTrack\n   * @private\n   */\n  _attach(el, mediaStreamTrack = this.processedTrack || this.mediaStreamTrack) {\n    let mediaStream = el.srcObject;\n    if (!(mediaStream instanceof this._MediaStream)) {\n      mediaStream = new this._MediaStream();\n    }\n\n    const getTracks = mediaStreamTrack.kind === 'audio'\n      ? 'getAudioTracks'\n      : 'getVideoTracks';\n\n    mediaStream[getTracks]().forEach(track => {\n      mediaStream.removeTrack(track);\n    });\n    mediaStream.addTrack(mediaStreamTrack);\n\n    // Map the element if a custom mapping function is provided\n    if (this._mapMediaElement) {\n      this._log.debug('Mapping element using mapMediaElement before attaching media to element');\n      this._mapMediaElement(el);\n    }\n\n    // NOTE(mpatwardhan): resetting `srcObject` here, causes flicker (JSDK-2641), but it lets us\n    // to sidestep the a chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1052353\n    el.srcObject = mediaStream;\n    el.autoplay = true;\n    el.playsInline = true;\n\n    if (!this._attachments.has(el)) {\n      this._attachments.add(el);\n    }\n\n    return el;\n  }\n\n  /**\n   * @private\n   */\n  _selectElement(selector) {\n    const el = document.querySelector(selector);\n\n    if (!el) {\n      throw new Error(`Selector matched no element: ${selector}`);\n    }\n\n    return el;\n  }\n\n  /**\n   * @private\n   */\n  _updateElementsMediaStreamTrack() {\n    this._log.debug('Reattaching all elements to update mediaStreamTrack');\n    this._getAllAttachedElements().forEach(el => this._attach(el));\n  }\n\n  /**\n   * @private\n   */\n  _createElement() {\n    return typeof document !== 'undefined'\n      ? document.createElement(this.kind)\n      : null;\n  }\n\n  detach(el) {\n    let els;\n\n    if (typeof el === 'string') {\n      els = [this._selectElement(el)];\n    } else if (!el) {\n      els = this._getAllAttachedElements();\n    } else {\n      els = [el];\n    }\n\n    this._log.debug('Attempting to detach from elements:', els);\n    this._detachElements(els);\n    return el ? els[0] : els;\n  }\n\n  /**\n   * @private\n   */\n  _detachElements(elements) {\n    return elements.map(this._detachElement.bind(this));\n  }\n\n  /**\n   * @private\n   */\n  _detachElement(el) {\n    if (!this._attachments.has(el)) {\n      return el;\n    }\n    const mediaStream = el.srcObject;\n    if (mediaStream instanceof this._MediaStream) {\n      mediaStream.removeTrack(this.processedTrack || this.mediaStreamTrack);\n    }\n    if (this._disposeMediaElement) {\n      this._log.debug('Disposing element using disposeMediaElement after removing media from element');\n      this._disposeMediaElement(el);\n    }\n    this._attachments.delete(el);\n\n    if (this._shouldShimAttachedElements && this._elShims.has(el)) {\n      const shim = this._elShims.get(el);\n      shim.unShim();\n      this._elShims.delete(el);\n    }\n\n    return el;\n  }\n\n  /**\n   * @private\n   */\n  _getAllAttachedElements() {\n    const els = [];\n\n    this._attachments.forEach(el => {\n      els.push(el);\n    });\n\n    return els;\n  }\n}\n\n/**\n * Play an HTMLMediaElement if it is paused and not backgrounded.\n * @private\n * @param {HTMLMediaElement} el\n * @param {Log} log\n * @returns {void}\n */\nfunction playIfPausedAndNotBackgrounded(el, log) {\n  const tag = el.tagName.toLowerCase();\n  log.warn('Unintentionally paused:', el);\n\n  // NOTE(mmalavalli): When the element is unintentionally paused, we wait one\n  // second for the \"onvisibilitychange\" event on the HTMLDocument to see if the\n  // app will be backgrounded. If not, then the element can be safely played.\n  Promise.race([\n    waitForEvent(document, 'visibilitychange'),\n    waitForSometime(1000)\n  ]).then(() => {\n    if (document.visibilityState === 'visible') {\n      // NOTE(mmalavalli): We play the inadvertently paused elements only after\n      // the LocalAudioTrack is unmuted to work around WebKit Bug 213853.\n      //\n      // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n      //\n      localMediaRestartDeferreds.whenResolved('audio').then(() => {\n        log.info(`Playing unintentionally paused <${tag}> element`);\n        log.debug('Element:', el);\n        return el.play();\n      }).then(() => {\n        log.info(`Successfully played unintentionally paused <${tag}> element`);\n        log.debug('Element:', el);\n      }).catch(error => {\n        log.warn(`Error while playing unintentionally paused <${tag}> element:`, { error, el });\n      });\n    }\n  });\n}\n\n/**\n * Shim the pause() and play() methods of the given HTMLMediaElement so that\n * we can detect if it was paused unintentionally.\n * @param {HTMLMediaElement} el\n * @param {?function} [onUnintentionallyPaused=null]\n * @returns {{pausedIntentionally: function, unShim: function}}\n */\nfunction shimMediaElement(el, onUnintentionallyPaused = null) {\n  const origPause = el.pause;\n  const origPlay = el.play;\n\n  let pausedIntentionally = false;\n\n  el.pause = () => {\n    pausedIntentionally = true;\n    return origPause.call(el);\n  };\n\n  el.play = () => {\n    pausedIntentionally = false;\n    return origPlay.call(el);\n  };\n\n  const onPause = onUnintentionallyPaused ? () => {\n    if (!pausedIntentionally) {\n      onUnintentionallyPaused();\n    }\n  } : null;\n\n  if (onPause) {\n    el.addEventListener('pause', onPause);\n  }\n\n  return {\n    pausedIntentionally() {\n      return pausedIntentionally;\n    },\n    unShim() {\n      el.pause = origPause;\n      el.play = origPlay;\n      if (onPause) {\n        el.removeEventListener('pause', onPause);\n      }\n    }\n  };\n}\n\nmodule.exports = MediaTrack;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}