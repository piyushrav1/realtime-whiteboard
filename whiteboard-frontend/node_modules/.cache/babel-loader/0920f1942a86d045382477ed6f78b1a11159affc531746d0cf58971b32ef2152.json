{"ast":null,"code":"/* eslint new-cap:0 */\n'use strict';\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar getUserMedia = require('../../webrtc').getUserMedia;\nvar isIOS = require('../../util/browserdetection').isIOS;\nvar _a = require('../../util'),\n  capitalize = _a.capitalize,\n  defer = _a.defer,\n  waitForSometime = _a.waitForSometime,\n  waitForEvent = _a.waitForEvent;\nvar ILLEGAL_INVOKE = require('../../util/constants').typeErrors.ILLEGAL_INVOKE;\nvar detectSilentAudio = require('../../util/detectsilentaudio');\nvar detectSilentVideo = require('../../util/detectsilentvideo');\nvar documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\nvar localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nvar gUMSilentTrackWorkaround = require('../../webaudio/workaround180748');\nvar MediaTrackSender = require('./sender');\nfunction mixinLocalMediaTrack(AudioOrVideoTrack) {\n  /**\n   * A {@link LocalMediaTrack} represents audio or video that your\n   * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be\n   * enabled and disabled with {@link LocalMediaTrack#enable} and\n   * {@link LocalMediaTrack#disable} or stopped completely with\n   * {@link LocalMediaTrack#stop}.\n   * @emits LocalMediaTrack#muted\n   * @emits LocalMediaTrack#stopped\n   * @emits LocalMediaTrack#unmuted\n   */\n  return /** @class */function (_super) {\n    __extends(LocalMediaTrack, _super);\n    /**\n     * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.\n     * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n     * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n     */\n    function LocalMediaTrack(mediaStreamTrack, options) {\n      var _this = this;\n      var workaroundWebKitBug1208516 = isIOS() && typeof document === 'object' && typeof document.addEventListener === 'function' && typeof document.visibilityState === 'string';\n      options = Object.assign({\n        getUserMedia: getUserMedia,\n        isCreatedByCreateLocalTracks: false,\n        workaroundWebKitBug1208516: workaroundWebKitBug1208516,\n        gUMSilentTrackWorkaround: gUMSilentTrackWorkaround\n      }, options);\n      var mediaTrackSender = new MediaTrackSender(mediaStreamTrack);\n      var kind = mediaTrackSender.kind;\n      _this = _super.call(this, mediaTrackSender, options) || this;\n      Object.defineProperties(_this, {\n        _constraints: {\n          value: typeof options[kind] === 'object' ? options[kind] : {},\n          writable: true\n        },\n        _getUserMedia: {\n          value: options.getUserMedia\n        },\n        _gUMSilentTrackWorkaround: {\n          value: options.gUMSilentTrackWorkaround\n        },\n        _eventsToReemitters: {\n          value: new Map([['muted', function () {\n            return _this.emit('muted', _this);\n          }], ['unmuted', function () {\n            return _this.emit('unmuted', _this);\n          }]])\n        },\n        _workaroundWebKitBug1208516: {\n          value: options.workaroundWebKitBug1208516\n        },\n        _workaroundWebKitBug1208516Cleanup: {\n          value: null,\n          writable: true\n        },\n        _didCallEnd: {\n          value: false,\n          writable: true\n        },\n        _isCreatedByCreateLocalTracks: {\n          value: options.isCreatedByCreateLocalTracks\n        },\n        _noiseCancellation: {\n          value: options.noiseCancellation || null\n        },\n        _trackSender: {\n          value: mediaTrackSender\n        },\n        id: {\n          enumerable: true,\n          value: mediaTrackSender.id\n        },\n        isEnabled: {\n          enumerable: true,\n          get: function () {\n            return mediaTrackSender.enabled;\n          }\n        },\n        isMuted: {\n          enumerable: true,\n          get: function () {\n            return mediaTrackSender.muted;\n          }\n        },\n        isStopped: {\n          enumerable: true,\n          get: function () {\n            return mediaTrackSender.readyState === 'ended';\n          }\n        }\n      });\n      // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,\n      // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.\n      if (_this._workaroundWebKitBug1208516) {\n        _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n      }\n      _this._reemitTrackSenderEvents();\n      return _this;\n    }\n    /**\n     * @private\n     */\n    LocalMediaTrack.prototype._end = function () {\n      var _this = this;\n      if (this._didCallEnd) {\n        return;\n      }\n      _super.prototype._end.call(this);\n      this._didCallEnd = true;\n      this._eventsToReemitters.forEach(function (reemitter, event) {\n        return _this._trackSender.removeListener(event, reemitter);\n      });\n      this.emit('stopped', this);\n    };\n    /**\n     * @private\n     */\n    LocalMediaTrack.prototype._initialize = function () {\n      if (this._didCallEnd) {\n        this._didCallEnd = false;\n      }\n      if (this._eventsToReemitters) {\n        this._reemitTrackSenderEvents();\n      }\n      _super.prototype._initialize.call(this);\n    };\n    /**\n     * @private\n     */\n    LocalMediaTrack.prototype._reacquireTrack = function (constraints) {\n      var _a;\n      var _b = this,\n        getUserMedia = _b._getUserMedia,\n        gUMSilentTrackWorkaround = _b._gUMSilentTrackWorkaround,\n        log = _b._log,\n        kind = _b.mediaStreamTrack.kind;\n      log.info('Re-acquiring the MediaStreamTrack');\n      log.debug('Constraints:', constraints);\n      var gUMConstraints = Object.assign({\n        audio: false,\n        video: false\n      }, (_a = {}, _a[kind] = constraints, _a));\n      var gUMPromise = this._workaroundWebKitBug1208516Cleanup ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints) : getUserMedia(gUMConstraints);\n      return gUMPromise.then(function (mediaStream) {\n        return mediaStream.getTracks()[0];\n      });\n    };\n    /**\n     * @private\n     */\n    LocalMediaTrack.prototype._reemitTrackSenderEvents = function () {\n      var _this = this;\n      this._eventsToReemitters.forEach(function (reemitter, event) {\n        return _this._trackSender.on(event, reemitter);\n      });\n      this._trackSender.dequeue('muted');\n      this._trackSender.dequeue('unmuted');\n    };\n    /**\n     * @private\n     */\n    LocalMediaTrack.prototype._restart = function (constraints) {\n      var _this = this;\n      var log = this._log;\n      constraints = constraints || this._constraints;\n      // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n      // without stopping it first, then a NotReadableError is raised in case of\n      // video, or the restarted audio will still be silent. Hence, we stop the\n      // MediaStreamTrack here.\n      this._stop();\n      return this._reacquireTrack(constraints).catch(function (error) {\n        log.error('Failed to re-acquire the MediaStreamTrack:', {\n          error: error,\n          constraints: constraints\n        });\n        throw error;\n      }).then(function (newMediaStreamTrack) {\n        log.info('Re-acquired the MediaStreamTrack');\n        log.debug('MediaStreamTrack:', newMediaStreamTrack);\n        _this._constraints = Object.assign({}, constraints);\n        return _this._setMediaStreamTrack(newMediaStreamTrack);\n      });\n    };\n    /**\n     * @private\n     */\n    LocalMediaTrack.prototype._setMediaStreamTrack = function (mediaStreamTrack) {\n      var _this = this;\n      // NOTE(mpatwardhan): Preserve the value of the \"enabled\" flag.\n      mediaStreamTrack.enabled = this.mediaStreamTrack.enabled;\n      // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already\n      // stopped, this should fire a \"stopped\" event.\n      this._stop();\n      // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has\n      // the processedTrack already set, we don't want to replace that.\n      return (this._unprocessedTrack ? Promise.resolve().then(function () {\n        _this._unprocessedTrack = mediaStreamTrack;\n      }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(function (error) {\n        _this._log.warn('setMediaStreamTrack failed:', {\n          error: error,\n          mediaStreamTrack: mediaStreamTrack\n        });\n      })).then(function () {\n        _this._initialize();\n        _this._getAllAttachedElements().forEach(function (el) {\n          return _this._attach(el);\n        });\n      });\n    };\n    /**\n     * @private\n     */\n    LocalMediaTrack.prototype._stop = function () {\n      this.mediaStreamTrack.stop();\n      this._end();\n      return this;\n    };\n    LocalMediaTrack.prototype.enable = function (enabled) {\n      enabled = typeof enabled === 'boolean' ? enabled : true;\n      if (enabled !== this.mediaStreamTrack.enabled) {\n        this._log.info((enabled ? 'En' : 'Dis') + \"abling\");\n        this.mediaStreamTrack.enabled = enabled;\n        this.emit(enabled ? 'enabled' : 'disabled', this);\n      }\n      return this;\n    };\n    LocalMediaTrack.prototype.disable = function () {\n      return this.enable(false);\n    };\n    LocalMediaTrack.prototype.restart = function (constraints) {\n      var _this = this;\n      var kind = this.kind;\n      if (!this._isCreatedByCreateLocalTracks) {\n        return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a' + (\" Local\" + capitalize(kind) + \"Track that is created using createLocalTracks\") + (\" or createLocal\" + capitalize(kind) + \"Track.\")));\n      }\n      if (this._workaroundWebKitBug1208516Cleanup) {\n        this._workaroundWebKitBug1208516Cleanup();\n        this._workaroundWebKitBug1208516Cleanup = null;\n      }\n      var promise = this._restart(constraints);\n      if (this._workaroundWebKitBug1208516) {\n        promise = promise.finally(function () {\n          _this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(_this);\n        });\n      }\n      return promise;\n    };\n    LocalMediaTrack.prototype.stop = function () {\n      this._log.info('Stopping');\n      if (this._workaroundWebKitBug1208516Cleanup) {\n        this._workaroundWebKitBug1208516Cleanup();\n        this._workaroundWebKitBug1208516Cleanup = null;\n      }\n      return this._stop();\n    };\n    return LocalMediaTrack;\n  }(AudioOrVideoTrack);\n}\n/**\n * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.\n * @private\n * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack\n * @returns {function} Clean up listeners attached by the workaround\n */\nfunction restartWhenInadvertentlyStopped(localMediaTrack) {\n  var log = localMediaTrack._log,\n    kind = localMediaTrack.kind,\n    noiseCancellation = localMediaTrack._noiseCancellation;\n  var detectSilence = {\n    audio: detectSilentAudio,\n    video: detectSilentVideo\n  }[kind];\n  var getSourceMediaStreamTrack = function () {\n    return noiseCancellation ? noiseCancellation.sourceTrack : localMediaTrack.mediaStreamTrack;\n  };\n  var el = localMediaTrack._dummyEl;\n  var mediaStreamTrack = getSourceMediaStreamTrack();\n  var trackChangeInProgress = null;\n  function checkSilence() {\n    // The dummy element is paused, so play it and then detect silence.\n    return el.play().then(function () {\n      return detectSilence(el);\n    }).then(function (isSilent) {\n      if (isSilent) {\n        log.warn('Silence detected');\n      } else {\n        log.info('Non-silence detected');\n      }\n      return isSilent;\n    }).catch(function (error) {\n      log.warn('Failed to detect silence:', error);\n    }).finally(function () {\n      // Pause the dummy element again, if there is no processed track.\n      if (!localMediaTrack.processedTrack) {\n        el.pause();\n      }\n    });\n  }\n  function shouldReacquireTrack() {\n    var _workaroundWebKitBug1208516Cleanup = localMediaTrack._workaroundWebKitBug1208516Cleanup,\n      isStopped = localMediaTrack.isStopped;\n    var isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup;\n    var muted = getSourceMediaStreamTrack().muted;\n    // NOTE(mmalavalli): Restart the LocalMediaTrack if:\n    // 1. The app is foregrounded, and\n    // 2. A restart is not already in progress, and\n    // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent\n    return Promise.resolve().then(function () {\n      return document.visibilityState === 'visible' && !trackChangeInProgress && (muted || isInadvertentlyStopped || checkSilence());\n    });\n  }\n  function maybeRestart() {\n    return Promise.race([waitForEvent(mediaStreamTrack, 'unmute'), waitForSometime(50)]).then(function () {\n      return shouldReacquireTrack();\n    }).then(function (shouldReacquire) {\n      if (shouldReacquire && !trackChangeInProgress) {\n        trackChangeInProgress = defer();\n        localMediaTrack._restart().finally(function () {\n          el = localMediaTrack._dummyEl;\n          removeMediaStreamTrackListeners();\n          mediaStreamTrack = getSourceMediaStreamTrack();\n          addMediaStreamTrackListeners();\n          trackChangeInProgress.resolve();\n          trackChangeInProgress = null;\n        }).catch(function (error) {\n          log.error('failed to restart track: ', error);\n        });\n      }\n      // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,\n      // then this makes sure that visibility callback for phase 2 is called only\n      // after the MediaStreamTrack is re-acquired.\n      var promise = trackChangeInProgress && trackChangeInProgress.promise || Promise.resolve();\n      return promise.finally(function () {\n        return localMediaRestartDeferreds.resolveDeferred(kind);\n      });\n    }).catch(function (ex) {\n      log.error(\"error in maybeRestart: \" + ex.message);\n    });\n  }\n  function onMute() {\n    var log = localMediaTrack._log,\n      kind = localMediaTrack.kind;\n    log.info('Muted');\n    log.debug('LocalMediaTrack:', localMediaTrack);\n    // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being\n    // backgrounded, and the inadvertently paused elements are played before it\n    // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,\n    // setting this Deferred will make sure that the inadvertently paused elements\n    // are played only after the LocalMediaTrack is unmuted.\n    //\n    // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n    //\n    localMediaRestartDeferreds.startDeferred(kind);\n  }\n  function addMediaStreamTrackListeners() {\n    if (mediaStreamTrack.addEventListener) {\n      mediaStreamTrack.addEventListener('ended', maybeRestart);\n      mediaStreamTrack.addEventListener('mute', onMute);\n      mediaStreamTrack.addEventListener('unmute', maybeRestart);\n    } else {\n      mediaStreamTrack.onended = maybeRestart;\n      mediaStreamTrack.onmute = onMute;\n      mediaStreamTrack.onunmute = maybeRestart;\n    }\n  }\n  function removeMediaStreamTrackListeners() {\n    if (mediaStreamTrack.removeEventListener) {\n      mediaStreamTrack.removeEventListener('ended', maybeRestart);\n      mediaStreamTrack.removeEventListener('mute', onMute);\n      mediaStreamTrack.removeEventListener('unmute', maybeRestart);\n    } else {\n      mediaStreamTrack.onended = null;\n      mediaStreamTrack.onmute = null;\n      mediaStreamTrack.onunmute = null;\n    }\n  }\n  // NOTE(mpatwardhan): listen for document visibility callback on phase 1.\n  // this ensures that we acquire media tracks before RemoteMediaTrack\n  // tries to `play` them (in phase 2). This order is important because\n  // play can fail on safari if audio is not being captured.\n  var onVisibilityChange = function (isVisible) {\n    return isVisible ? maybeRestart() : false;\n  };\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);\n  addMediaStreamTrackListeners();\n  return function () {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);\n    removeMediaStreamTrackListeners();\n  };\n}\nmodule.exports = mixinLocalMediaTrack;","map":{"version":3,"names":["getUserMedia","require","isIOS","_a","capitalize","defer","waitForSometime","waitForEvent","ILLEGAL_INVOKE","typeErrors","detectSilentAudio","detectSilentVideo","documentVisibilityMonitor","localMediaRestartDeferreds","gUMSilentTrackWorkaround","MediaTrackSender","mixinLocalMediaTrack","AudioOrVideoTrack","_super","__extends","LocalMediaTrack","mediaStreamTrack","options","_this","workaroundWebKitBug1208516","document","addEventListener","visibilityState","Object","assign","isCreatedByCreateLocalTracks","mediaTrackSender","kind","call","defineProperties","_constraints","value","writable","_getUserMedia","_gUMSilentTrackWorkaround","_eventsToReemitters","Map","emit","_workaroundWebKitBug1208516","_workaroundWebKitBug1208516Cleanup","_didCallEnd","_isCreatedByCreateLocalTracks","_noiseCancellation","noiseCancellation","_trackSender","id","enumerable","isEnabled","get","enabled","isMuted","muted","isStopped","readyState","restartWhenInadvertentlyStopped","_reemitTrackSenderEvents","prototype","_end","forEach","reemitter","event","removeListener","_initialize","_reacquireTrack","constraints","_b","log","_log","info","debug","gUMConstraints","audio","video","gUMPromise","then","mediaStream","getTracks","on","dequeue","_restart","_stop","catch","error","newMediaStreamTrack","_setMediaStreamTrack","_unprocessedTrack","Promise","resolve","setMediaStreamTrack","warn","_getAllAttachedElements","el","_attach","stop","enable","disable","restart","reject","promise","finally","localMediaTrack","detectSilence","getSourceMediaStreamTrack","sourceTrack","_dummyEl","trackChangeInProgress","checkSilence","play","isSilent","processedTrack","pause","shouldReacquireTrack","isInadvertentlyStopped","maybeRestart","race","shouldReacquire","removeMediaStreamTrackListeners","addMediaStreamTrackListeners","resolveDeferred","ex","message","onMute","startDeferred","onended","onmute","onunmute","removeEventListener","onVisibilityChange","isVisible","offVisibilityChange","module","exports"],"sources":["C:\\Users\\gamin\\OneDrive\\Desktop\\Project\\Whiteboard\\live-whiteboard-app\\whiteboard-frontend\\node_modules\\twilio-video\\lib\\media\\track\\localmediatrack.js"],"sourcesContent":["/* eslint new-cap:0 */\n'use strict';\n\nconst { getUserMedia } = require('../../webrtc');\nconst { isIOS } = require('../../util/browserdetection');\n\nconst { capitalize, defer, waitForSometime, waitForEvent } = require('../../util');\nconst { typeErrors: { ILLEGAL_INVOKE } } = require('../../util/constants');\nconst detectSilentAudio = require('../../util/detectsilentaudio');\nconst detectSilentVideo = require('../../util/detectsilentvideo');\nconst documentVisibilityMonitor = require('../../util/documentvisibilitymonitor.js');\nconst localMediaRestartDeferreds = require('../../util/localmediarestartdeferreds');\nconst gUMSilentTrackWorkaround = require('../../webaudio/workaround180748');\nconst MediaTrackSender = require('./sender');\n\nfunction mixinLocalMediaTrack(AudioOrVideoTrack) {\n  /**\n   * A {@link LocalMediaTrack} represents audio or video that your\n   * {@link LocalParticipant} is sending to a {@link Room}. As such, it can be\n   * enabled and disabled with {@link LocalMediaTrack#enable} and\n   * {@link LocalMediaTrack#disable} or stopped completely with\n   * {@link LocalMediaTrack#stop}.\n   * @emits LocalMediaTrack#muted\n   * @emits LocalMediaTrack#stopped\n   * @emits LocalMediaTrack#unmuted\n   */\n  return class LocalMediaTrack extends AudioOrVideoTrack {\n    /**\n     * Construct a {@link LocalMediaTrack} from a MediaStreamTrack.\n     * @param {MediaStreamTrack} mediaStreamTrack - The underlying MediaStreamTrack\n     * @param {LocalTrackOptions} [options] - {@link LocalTrack} options\n     */\n    constructor(mediaStreamTrack, options) {\n      const workaroundWebKitBug1208516 = isIOS()\n        && typeof document === 'object'\n        && typeof document.addEventListener === 'function'\n        && typeof document.visibilityState === 'string';\n\n      options = Object.assign({\n        getUserMedia,\n        isCreatedByCreateLocalTracks: false,\n        workaroundWebKitBug1208516,\n        gUMSilentTrackWorkaround\n      }, options);\n\n      const mediaTrackSender = new MediaTrackSender(mediaStreamTrack);\n      const { kind } = mediaTrackSender;\n\n      super(mediaTrackSender, options);\n\n      Object.defineProperties(this, {\n        _constraints: {\n          value: typeof options[kind] === 'object'\n            ? options[kind]\n            : {},\n          writable: true\n        },\n        _getUserMedia: {\n          value: options.getUserMedia\n        },\n        _gUMSilentTrackWorkaround: {\n          value: options.gUMSilentTrackWorkaround\n        },\n        _eventsToReemitters: {\n          value: new Map([\n            ['muted', () => this.emit('muted', this)],\n            ['unmuted', () => this.emit('unmuted', this)]\n          ])\n        },\n        _workaroundWebKitBug1208516: {\n          value: options.workaroundWebKitBug1208516\n        },\n        _workaroundWebKitBug1208516Cleanup: {\n          value: null,\n          writable: true\n        },\n        _didCallEnd: {\n          value: false,\n          writable: true\n        },\n        _isCreatedByCreateLocalTracks: {\n          value: options.isCreatedByCreateLocalTracks\n        },\n        _noiseCancellation: {\n          value: options.noiseCancellation || null\n        },\n        _trackSender: {\n          value: mediaTrackSender\n        },\n        id: {\n          enumerable: true,\n          value: mediaTrackSender.id\n        },\n        isEnabled: {\n          enumerable: true,\n          get() {\n            return mediaTrackSender.enabled;\n          }\n        },\n        isMuted: {\n          enumerable: true,\n          get() {\n            return mediaTrackSender.muted;\n          }\n        },\n        isStopped: {\n          enumerable: true,\n          get() {\n            return mediaTrackSender.readyState === 'ended';\n          }\n        }\n      });\n\n      // NOTE(mpatwardhan): As a workaround for WebKit bug: https://bugs.webkit.org/show_bug.cgi?id=208516,\n      // upon foregrounding, re-acquire new MediaStreamTrack if the existing one is ended or muted.\n      if (this._workaroundWebKitBug1208516) {\n        this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(this);\n      }\n\n      this._reemitTrackSenderEvents();\n    }\n\n    /**\n     * @private\n     */\n    _end() {\n      if (this._didCallEnd) {\n        return;\n      }\n      super._end.call(this);\n      this._didCallEnd = true;\n      this._eventsToReemitters.forEach((reemitter, event) => this._trackSender.removeListener(event, reemitter));\n      this.emit('stopped', this);\n    }\n\n    /**\n     * @private\n     */\n    _initialize() {\n      if (this._didCallEnd) {\n        this._didCallEnd = false;\n      }\n      if (this._eventsToReemitters) {\n        this._reemitTrackSenderEvents();\n      }\n      super._initialize.call(this);\n    }\n\n    /**\n     * @private\n     */\n    _reacquireTrack(constraints) {\n      const {\n        _getUserMedia: getUserMedia,\n        _gUMSilentTrackWorkaround: gUMSilentTrackWorkaround,\n        _log: log,\n        mediaStreamTrack: { kind }\n      } = this;\n\n      log.info('Re-acquiring the MediaStreamTrack');\n      log.debug('Constraints:', constraints);\n\n      const gUMConstraints = Object.assign({\n        audio: false,\n        video: false\n      }, { [kind]: constraints });\n\n      const gUMPromise = this._workaroundWebKitBug1208516Cleanup\n        ? gUMSilentTrackWorkaround(log, getUserMedia, gUMConstraints)\n        : getUserMedia(gUMConstraints);\n\n      return gUMPromise.then(mediaStream => {\n        return mediaStream.getTracks()[0];\n      });\n    }\n\n    /**\n     * @private\n     */\n    _reemitTrackSenderEvents() {\n      this._eventsToReemitters.forEach((reemitter, event) => this._trackSender.on(event, reemitter));\n      this._trackSender.dequeue('muted');\n      this._trackSender.dequeue('unmuted');\n    }\n\n    /**\n     * @private\n     */\n    _restart(constraints) {\n      const { _log: log } = this;\n      constraints = constraints || this._constraints;\n\n      // NOTE(mmalavalli): If we try and restart a silent MediaStreamTrack\n      // without stopping it first, then a NotReadableError is raised in case of\n      // video, or the restarted audio will still be silent. Hence, we stop the\n      // MediaStreamTrack here.\n      this._stop();\n\n      return this._reacquireTrack(constraints).catch(error => {\n        log.error('Failed to re-acquire the MediaStreamTrack:', { error, constraints });\n        throw error;\n      }).then(newMediaStreamTrack => {\n        log.info('Re-acquired the MediaStreamTrack');\n        log.debug('MediaStreamTrack:', newMediaStreamTrack);\n        this._constraints = Object.assign({}, constraints);\n        return this._setMediaStreamTrack(newMediaStreamTrack);\n      });\n    }\n\n    /**\n     * @private\n     */\n    _setMediaStreamTrack(mediaStreamTrack) {\n      // NOTE(mpatwardhan): Preserve the value of the \"enabled\" flag.\n      mediaStreamTrack.enabled = this.mediaStreamTrack.enabled;\n\n      // NOTE(mmalavalli): Stop the current MediaStreamTrack. If not already\n      // stopped, this should fire a \"stopped\" event.\n      this._stop();\n\n      // NOTE(csantos): If there's an unprocessedTrack, this means RTCRtpSender has\n      // the processedTrack already set, we don't want to replace that.\n      return (this._unprocessedTrack ? Promise.resolve().then(() => {\n        this._unprocessedTrack = mediaStreamTrack;\n      }) : this._trackSender.setMediaStreamTrack(mediaStreamTrack).catch(error => {\n        this._log.warn('setMediaStreamTrack failed:', { error, mediaStreamTrack });\n      })).then(() => {\n        this._initialize();\n        this._getAllAttachedElements().forEach(el => this._attach(el));\n      });\n    }\n\n    /**\n     * @private\n     */\n    _stop() {\n      this.mediaStreamTrack.stop();\n      this._end();\n      return this;\n    }\n\n    enable(enabled) {\n      enabled = typeof enabled === 'boolean' ? enabled : true;\n      if (enabled !== this.mediaStreamTrack.enabled) {\n        this._log.info(`${enabled ? 'En' : 'Dis'}abling`);\n        this.mediaStreamTrack.enabled = enabled;\n        this.emit(enabled ? 'enabled' : 'disabled', this);\n      }\n      return this;\n    }\n\n    disable() {\n      return this.enable(false);\n    }\n\n    restart(constraints) {\n      const { kind } = this;\n      if (!this._isCreatedByCreateLocalTracks) {\n        return Promise.reject(ILLEGAL_INVOKE('restart', 'can only be called on a'\n          + ` Local${capitalize(kind)}Track that is created using createLocalTracks`\n          + ` or createLocal${capitalize(kind)}Track.`));\n      }\n      if (this._workaroundWebKitBug1208516Cleanup) {\n        this._workaroundWebKitBug1208516Cleanup();\n        this._workaroundWebKitBug1208516Cleanup = null;\n      }\n      let promise = this._restart(constraints);\n\n      if (this._workaroundWebKitBug1208516) {\n        promise = promise.finally(() => {\n          this._workaroundWebKitBug1208516Cleanup = restartWhenInadvertentlyStopped(this);\n        });\n      }\n      return promise;\n    }\n\n    stop() {\n      this._log.info('Stopping');\n      if (this._workaroundWebKitBug1208516Cleanup) {\n        this._workaroundWebKitBug1208516Cleanup();\n        this._workaroundWebKitBug1208516Cleanup = null;\n      }\n      return this._stop();\n    }\n  };\n}\n\n/**\n * Restart the given {@link LocalMediaTrack} if it has been inadvertently stopped.\n * @private\n * @param {LocalAudioTrack|LocalVideoTrack} localMediaTrack\n * @returns {function} Clean up listeners attached by the workaround\n */\nfunction restartWhenInadvertentlyStopped(localMediaTrack) {\n  const {\n    _log: log,\n    kind,\n    _noiseCancellation: noiseCancellation\n  } = localMediaTrack;\n\n  const detectSilence = {\n    audio: detectSilentAudio,\n    video: detectSilentVideo\n  }[kind];\n\n  const getSourceMediaStreamTrack = () => noiseCancellation\n    ? noiseCancellation.sourceTrack\n    : localMediaTrack.mediaStreamTrack;\n\n  let { _dummyEl: el } = localMediaTrack;\n  let mediaStreamTrack = getSourceMediaStreamTrack();\n  let trackChangeInProgress = null;\n\n  function checkSilence() {\n    // The dummy element is paused, so play it and then detect silence.\n    return el.play().then(() => detectSilence(el)).then(isSilent => {\n      if (isSilent) {\n        log.warn('Silence detected');\n      } else {\n        log.info('Non-silence detected');\n      }\n      return isSilent;\n    }).catch(error => {\n      log.warn('Failed to detect silence:', error);\n    }).finally(() => {\n      // Pause the dummy element again, if there is no processed track.\n      if (!localMediaTrack.processedTrack) {\n        el.pause();\n      }\n    });\n  }\n\n  function shouldReacquireTrack() {\n    const {\n      _workaroundWebKitBug1208516Cleanup,\n      isStopped\n    } = localMediaTrack;\n\n    const isInadvertentlyStopped = isStopped && !!_workaroundWebKitBug1208516Cleanup;\n    const { muted } = getSourceMediaStreamTrack();\n\n    // NOTE(mmalavalli): Restart the LocalMediaTrack if:\n    // 1. The app is foregrounded, and\n    // 2. A restart is not already in progress, and\n    // 3. The LocalMediaTrack is either muted, inadvertently stopped or silent\n    return Promise.resolve().then(() => {\n      return document.visibilityState === 'visible'\n        && !trackChangeInProgress\n        && (muted || isInadvertentlyStopped || checkSilence());\n    });\n  }\n\n  function maybeRestart() {\n    return Promise.race([\n      waitForEvent(mediaStreamTrack, 'unmute'),\n      waitForSometime(50)\n    ]).then(() => shouldReacquireTrack()).then(shouldReacquire => {\n      if (shouldReacquire && !trackChangeInProgress) {\n        trackChangeInProgress = defer();\n        localMediaTrack._restart().finally(() => {\n          el = localMediaTrack._dummyEl;\n          removeMediaStreamTrackListeners();\n          mediaStreamTrack = getSourceMediaStreamTrack();\n          addMediaStreamTrackListeners();\n          trackChangeInProgress.resolve();\n          trackChangeInProgress = null;\n        }).catch(error => {\n          log.error('failed to restart track: ', error);\n        });\n      }\n\n      // NOTE(mmalavalli): If the MediaStreamTrack ends before the DOM is visible,\n      // then this makes sure that visibility callback for phase 2 is called only\n      // after the MediaStreamTrack is re-acquired.\n      const promise = (trackChangeInProgress && trackChangeInProgress.promise) || Promise.resolve();\n      return promise.finally(() => localMediaRestartDeferreds.resolveDeferred(kind));\n    }).catch(ex => {\n      log.error(`error in maybeRestart: ${ex.message}`);\n    });\n  }\n\n  function onMute() {\n    const { _log: log, kind } = localMediaTrack;\n    log.info('Muted');\n    log.debug('LocalMediaTrack:', localMediaTrack);\n\n    // NOTE(mmalavalli): When a LocalMediaTrack is muted without the app being\n    // backgrounded, and the inadvertently paused elements are played before it\n    // is restarted, it never gets unmuted due to the WebKit Bug 213853. Hence,\n    // setting this Deferred will make sure that the inadvertently paused elements\n    // are played only after the LocalMediaTrack is unmuted.\n    //\n    // Bug: https://bugs.webkit.org/show_bug.cgi?id=213853\n    //\n    localMediaRestartDeferreds.startDeferred(kind);\n  }\n\n  function addMediaStreamTrackListeners() {\n    if (mediaStreamTrack.addEventListener) {\n      mediaStreamTrack.addEventListener('ended', maybeRestart);\n      mediaStreamTrack.addEventListener('mute', onMute);\n      mediaStreamTrack.addEventListener('unmute', maybeRestart);\n    } else {\n      mediaStreamTrack.onended = maybeRestart;\n      mediaStreamTrack.onmute = onMute;\n      mediaStreamTrack.onunmute = maybeRestart;\n    }\n  }\n\n  function removeMediaStreamTrackListeners() {\n    if (mediaStreamTrack.removeEventListener) {\n      mediaStreamTrack.removeEventListener('ended', maybeRestart);\n      mediaStreamTrack.removeEventListener('mute', onMute);\n      mediaStreamTrack.removeEventListener('unmute', maybeRestart);\n    } else {\n      mediaStreamTrack.onended = null;\n      mediaStreamTrack.onmute = null;\n      mediaStreamTrack.onunmute = null;\n    }\n  }\n\n  // NOTE(mpatwardhan): listen for document visibility callback on phase 1.\n  // this ensures that we acquire media tracks before RemoteMediaTrack\n  // tries to `play` them (in phase 2). This order is important because\n  // play can fail on safari if audio is not being captured.\n  let onVisibilityChange = isVisible => {\n    return isVisible ? maybeRestart() : false;\n  };\n  documentVisibilityMonitor.onVisibilityChange(1, onVisibilityChange);\n  addMediaStreamTrackListeners();\n\n  return () => {\n    documentVisibilityMonitor.offVisibilityChange(1, onVisibilityChange);\n    removeMediaStreamTrackListeners();\n  };\n}\n\nmodule.exports = mixinLocalMediaTrack;\n"],"mappings":"AAAA;AACA,YAAY;;;;;;;;;;;;;;;;;;;;;;AAEJ,IAAAA,YAAY,GAAKC,OAAO,CAAC,cAAc,CAAC,CAAAD,YAA5B;AACZ,IAAAE,KAAK,GAAKD,OAAO,CAAC,6BAA6B,CAAC,CAAAC,KAA3C;AAEP,IAAAC,EAAA,GAAuDF,OAAO,CAAC,YAAY,CAAC;EAA1EG,UAAU,GAAAD,EAAA,CAAAC,UAAA;EAAEC,KAAK,GAAAF,EAAA,CAAAE,KAAA;EAAEC,eAAe,GAAAH,EAAA,CAAAG,eAAA;EAAEC,YAAY,GAAAJ,EAAA,CAAAI,YAA0B;AAC5D,IAAAC,cAAc,GAAOP,OAAO,CAAC,sBAAsB,CAAC,CAAAQ,UAAA,CAAAD,cAAtC;AACpC,IAAME,iBAAiB,GAAGT,OAAO,CAAC,8BAA8B,CAAC;AACjE,IAAMU,iBAAiB,GAAGV,OAAO,CAAC,8BAA8B,CAAC;AACjE,IAAMW,yBAAyB,GAAGX,OAAO,CAAC,yCAAyC,CAAC;AACpF,IAAMY,0BAA0B,GAAGZ,OAAO,CAAC,uCAAuC,CAAC;AACnF,IAAMa,wBAAwB,GAAGb,OAAO,CAAC,iCAAiC,CAAC;AAC3E,IAAMc,gBAAgB,GAAGd,OAAO,CAAC,UAAU,CAAC;AAE5C,SAASe,oBAAoBA,CAACC,iBAAiB;EAC7C;;;;;;;;;;EAUA,8BAAAC,MAAA;IAAqCC,SAAA,CAAAC,eAAA,EAAAF,MAAA;IACnC;;;;;IAKA,SAAAE,gBAAYC,gBAAgB,EAAEC,OAAO;MAArC,IAAAC,KAAA;MACE,IAAMC,0BAA0B,GAAGtB,KAAK,EAAE,IACrC,OAAOuB,QAAQ,KAAK,QAAQ,IAC5B,OAAOA,QAAQ,CAACC,gBAAgB,KAAK,UAAU,IAC/C,OAAOD,QAAQ,CAACE,eAAe,KAAK,QAAQ;MAEjDL,OAAO,GAAGM,MAAM,CAACC,MAAM,CAAC;QACtB7B,YAAY,EAAAA,YAAA;QACZ8B,4BAA4B,EAAE,KAAK;QACnCN,0BAA0B,EAAAA,0BAAA;QAC1BV,wBAAwB,EAAAA;OACzB,EAAEQ,OAAO,CAAC;MAEX,IAAMS,gBAAgB,GAAG,IAAIhB,gBAAgB,CAACM,gBAAgB,CAAC;MACvD,IAAAW,IAAI,GAAKD,gBAAgB,CAAAC,IAArB;MAEZT,KAAA,GAAAL,MAAA,CAAAe,IAAA,OAAMF,gBAAgB,EAAET,OAAO,CAAC;MAEhCM,MAAM,CAACM,gBAAgB,CAACX,KAAI,EAAE;QAC5BY,YAAY,EAAE;UACZC,KAAK,EAAE,OAAOd,OAAO,CAACU,IAAI,CAAC,KAAK,QAAQ,GACpCV,OAAO,CAACU,IAAI,CAAC,GACb,EAAE;UACNK,QAAQ,EAAE;SACX;QACDC,aAAa,EAAE;UACbF,KAAK,EAAEd,OAAO,CAACtB;SAChB;QACDuC,yBAAyB,EAAE;UACzBH,KAAK,EAAEd,OAAO,CAACR;SAChB;QACD0B,mBAAmB,EAAE;UACnBJ,KAAK,EAAE,IAAIK,GAAG,CAAC,CACb,CAAC,OAAO,EAAE;YAAM,OAAAlB,KAAI,CAACmB,IAAI,CAAC,OAAO,EAAEnB,KAAI,CAAC;UAAxB,CAAwB,CAAC,EACzC,CAAC,SAAS,EAAE;YAAM,OAAAA,KAAI,CAACmB,IAAI,CAAC,SAAS,EAAEnB,KAAI,CAAC;UAA1B,CAA0B,CAAC,CAC9C;SACF;QACDoB,2BAA2B,EAAE;UAC3BP,KAAK,EAAEd,OAAO,CAACE;SAChB;QACDoB,kCAAkC,EAAE;UAClCR,KAAK,EAAE,IAAI;UACXC,QAAQ,EAAE;SACX;QACDQ,WAAW,EAAE;UACXT,KAAK,EAAE,KAAK;UACZC,QAAQ,EAAE;SACX;QACDS,6BAA6B,EAAE;UAC7BV,KAAK,EAAEd,OAAO,CAACQ;SAChB;QACDiB,kBAAkB,EAAE;UAClBX,KAAK,EAAEd,OAAO,CAAC0B,iBAAiB,IAAI;SACrC;QACDC,YAAY,EAAE;UACZb,KAAK,EAAEL;SACR;QACDmB,EAAE,EAAE;UACFC,UAAU,EAAE,IAAI;UAChBf,KAAK,EAAEL,gBAAgB,CAACmB;SACzB;QACDE,SAAS,EAAE;UACTD,UAAU,EAAE,IAAI;UAChBE,GAAG,WAAAA,CAAA;YACD,OAAOtB,gBAAgB,CAACuB,OAAO;UACjC;SACD;QACDC,OAAO,EAAE;UACPJ,UAAU,EAAE,IAAI;UAChBE,GAAG,WAAAA,CAAA;YACD,OAAOtB,gBAAgB,CAACyB,KAAK;UAC/B;SACD;QACDC,SAAS,EAAE;UACTN,UAAU,EAAE,IAAI;UAChBE,GAAG,WAAAA,CAAA;YACD,OAAOtB,gBAAgB,CAAC2B,UAAU,KAAK,OAAO;UAChD;;OAEH,CAAC;MAEF;MACA;MACA,IAAInC,KAAI,CAACoB,2BAA2B,EAAE;QACpCpB,KAAI,CAACqB,kCAAkC,GAAGe,+BAA+B,CAACpC,KAAI,CAAC;;MAGjFA,KAAI,CAACqC,wBAAwB,EAAE;;IACjC;IAEA;;;IAGAxC,eAAA,CAAAyC,SAAA,CAAAC,IAAI,GAAJ;MAAA,IAAAvC,KAAA;MACE,IAAI,IAAI,CAACsB,WAAW,EAAE;QACpB;;MAEF3B,MAAA,CAAA2C,SAAA,CAAMC,IAAI,CAAC7B,IAAI,CAAC,IAAI,CAAC;MACrB,IAAI,CAACY,WAAW,GAAG,IAAI;MACvB,IAAI,CAACL,mBAAmB,CAACuB,OAAO,CAAC,UAACC,SAAS,EAAEC,KAAK;QAAK,OAAA1C,KAAI,CAAC0B,YAAY,CAACiB,cAAc,CAACD,KAAK,EAAED,SAAS,CAAC;MAAlD,CAAkD,CAAC;MAC1G,IAAI,CAACtB,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC;IAC5B,CAAC;IAED;;;IAGAtB,eAAA,CAAAyC,SAAA,CAAAM,WAAW,GAAX;MACE,IAAI,IAAI,CAACtB,WAAW,EAAE;QACpB,IAAI,CAACA,WAAW,GAAG,KAAK;;MAE1B,IAAI,IAAI,CAACL,mBAAmB,EAAE;QAC5B,IAAI,CAACoB,wBAAwB,EAAE;;MAEjC1C,MAAA,CAAA2C,SAAA,CAAMM,WAAW,CAAClC,IAAI,CAAC,IAAI,CAAC;IAC9B,CAAC;IAED;;;IAGAb,eAAA,CAAAyC,SAAA,CAAAO,eAAe,GAAf,UAAgBC,WAAW;;MACnB,IAAAC,EAAA,GAKF,IAAI;QAJStE,YAAY,GAAAsE,EAAA,CAAAhC,aAAA;QACAxB,wBAAwB,GAAAwD,EAAA,CAAA/B,yBAAA;QAC7CgC,GAAG,GAAAD,EAAA,CAAAE,IAAA;QACWxC,IAAI,GAAAsC,EAAA,CAAAjD,gBAAA,CAAAW,IAClB;MAERuC,GAAG,CAACE,IAAI,CAAC,mCAAmC,CAAC;MAC7CF,GAAG,CAACG,KAAK,CAAC,cAAc,EAAEL,WAAW,CAAC;MAEtC,IAAMM,cAAc,GAAG/C,MAAM,CAACC,MAAM,CAAC;QACnC+C,KAAK,EAAE,KAAK;QACZC,KAAK,EAAE;OACR,GAAA1E,EAAA,OAAIA,EAAA,CAAC6B,IAAI,IAAGqC,WAAW,EAAAlE,EAAA,EAAG;MAE3B,IAAM2E,UAAU,GAAG,IAAI,CAAClC,kCAAkC,GACtD9B,wBAAwB,CAACyD,GAAG,EAAEvE,YAAY,EAAE2E,cAAc,CAAC,GAC3D3E,YAAY,CAAC2E,cAAc,CAAC;MAEhC,OAAOG,UAAU,CAACC,IAAI,CAAC,UAAAC,WAAW;QAChC,OAAOA,WAAW,CAACC,SAAS,EAAE,CAAC,CAAC,CAAC;MACnC,CAAC,CAAC;IACJ,CAAC;IAED;;;IAGA7D,eAAA,CAAAyC,SAAA,CAAAD,wBAAwB,GAAxB;MAAA,IAAArC,KAAA;MACE,IAAI,CAACiB,mBAAmB,CAACuB,OAAO,CAAC,UAACC,SAAS,EAAEC,KAAK;QAAK,OAAA1C,KAAI,CAAC0B,YAAY,CAACiC,EAAE,CAACjB,KAAK,EAAED,SAAS,CAAC;MAAtC,CAAsC,CAAC;MAC9F,IAAI,CAACf,YAAY,CAACkC,OAAO,CAAC,OAAO,CAAC;MAClC,IAAI,CAAClC,YAAY,CAACkC,OAAO,CAAC,SAAS,CAAC;IACtC,CAAC;IAED;;;IAGA/D,eAAA,CAAAyC,SAAA,CAAAuB,QAAQ,GAAR,UAASf,WAAW;MAApB,IAAA9C,KAAA;MACU,IAAMgD,GAAG,GAAK,IAAI,CAAAC,IAAT;MACjBH,WAAW,GAAGA,WAAW,IAAI,IAAI,CAAClC,YAAY;MAE9C;MACA;MACA;MACA;MACA,IAAI,CAACkD,KAAK,EAAE;MAEZ,OAAO,IAAI,CAACjB,eAAe,CAACC,WAAW,CAAC,CAACiB,KAAK,CAAC,UAAAC,KAAK;QAClDhB,GAAG,CAACgB,KAAK,CAAC,4CAA4C,EAAE;UAAEA,KAAK,EAAAA,KAAA;UAAElB,WAAW,EAAAA;QAAA,CAAE,CAAC;QAC/E,MAAMkB,KAAK;MACb,CAAC,CAAC,CAACR,IAAI,CAAC,UAAAS,mBAAmB;QACzBjB,GAAG,CAACE,IAAI,CAAC,kCAAkC,CAAC;QAC5CF,GAAG,CAACG,KAAK,CAAC,mBAAmB,EAAEc,mBAAmB,CAAC;QACnDjE,KAAI,CAACY,YAAY,GAAGP,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEwC,WAAW,CAAC;QAClD,OAAO9C,KAAI,CAACkE,oBAAoB,CAACD,mBAAmB,CAAC;MACvD,CAAC,CAAC;IACJ,CAAC;IAED;;;IAGApE,eAAA,CAAAyC,SAAA,CAAA4B,oBAAoB,GAApB,UAAqBpE,gBAAgB;MAArC,IAAAE,KAAA;MACE;MACAF,gBAAgB,CAACiC,OAAO,GAAG,IAAI,CAACjC,gBAAgB,CAACiC,OAAO;MAExD;MACA;MACA,IAAI,CAAC+B,KAAK,EAAE;MAEZ;MACA;MACA,OAAO,CAAC,IAAI,CAACK,iBAAiB,GAAGC,OAAO,CAACC,OAAO,EAAE,CAACb,IAAI,CAAC;QACtDxD,KAAI,CAACmE,iBAAiB,GAAGrE,gBAAgB;MAC3C,CAAC,CAAC,GAAG,IAAI,CAAC4B,YAAY,CAAC4C,mBAAmB,CAACxE,gBAAgB,CAAC,CAACiE,KAAK,CAAC,UAAAC,KAAK;QACtEhE,KAAI,CAACiD,IAAI,CAACsB,IAAI,CAAC,6BAA6B,EAAE;UAAEP,KAAK,EAAAA,KAAA;UAAElE,gBAAgB,EAAAA;QAAA,CAAE,CAAC;MAC5E,CAAC,CAAC,EAAE0D,IAAI,CAAC;QACPxD,KAAI,CAAC4C,WAAW,EAAE;QAClB5C,KAAI,CAACwE,uBAAuB,EAAE,CAAChC,OAAO,CAAC,UAAAiC,EAAE;UAAI,OAAAzE,KAAI,CAAC0E,OAAO,CAACD,EAAE,CAAC;QAAhB,CAAgB,CAAC;MAChE,CAAC,CAAC;IACJ,CAAC;IAED;;;IAGA5E,eAAA,CAAAyC,SAAA,CAAAwB,KAAK,GAAL;MACE,IAAI,CAAChE,gBAAgB,CAAC6E,IAAI,EAAE;MAC5B,IAAI,CAACpC,IAAI,EAAE;MACX,OAAO,IAAI;IACb,CAAC;IAED1C,eAAA,CAAAyC,SAAA,CAAAsC,MAAM,GAAN,UAAO7C,OAAO;MACZA,OAAO,GAAG,OAAOA,OAAO,KAAK,SAAS,GAAGA,OAAO,GAAG,IAAI;MACvD,IAAIA,OAAO,KAAK,IAAI,CAACjC,gBAAgB,CAACiC,OAAO,EAAE;QAC7C,IAAI,CAACkB,IAAI,CAACC,IAAI,CAAC,CAAGnB,OAAO,GAAG,IAAI,GAAG,KAAK,YAAQ,CAAC;QACjD,IAAI,CAACjC,gBAAgB,CAACiC,OAAO,GAAGA,OAAO;QACvC,IAAI,CAACZ,IAAI,CAACY,OAAO,GAAG,SAAS,GAAG,UAAU,EAAE,IAAI,CAAC;;MAEnD,OAAO,IAAI;IACb,CAAC;IAEDlC,eAAA,CAAAyC,SAAA,CAAAuC,OAAO,GAAP;MACE,OAAO,IAAI,CAACD,MAAM,CAAC,KAAK,CAAC;IAC3B,CAAC;IAED/E,eAAA,CAAAyC,SAAA,CAAAwC,OAAO,GAAP,UAAQhC,WAAW;MAAnB,IAAA9C,KAAA;MACU,IAAAS,IAAI,GAAK,IAAI,CAAAA,IAAT;MACZ,IAAI,CAAC,IAAI,CAACc,6BAA6B,EAAE;QACvC,OAAO6C,OAAO,CAACW,MAAM,CAAC9F,cAAc,CAAC,SAAS,EAAE,yBAAyB,IACrE,WAASJ,UAAU,CAAC4B,IAAI,CAAC,kDAA+C,KACxE,oBAAkB5B,UAAU,CAAC4B,IAAI,CAAC,WAAQ,EAAC,CAAC;;MAElD,IAAI,IAAI,CAACY,kCAAkC,EAAE;QAC3C,IAAI,CAACA,kCAAkC,EAAE;QACzC,IAAI,CAACA,kCAAkC,GAAG,IAAI;;MAEhD,IAAI2D,OAAO,GAAG,IAAI,CAACnB,QAAQ,CAACf,WAAW,CAAC;MAExC,IAAI,IAAI,CAAC1B,2BAA2B,EAAE;QACpC4D,OAAO,GAAGA,OAAO,CAACC,OAAO,CAAC;UACxBjF,KAAI,CAACqB,kCAAkC,GAAGe,+BAA+B,CAACpC,KAAI,CAAC;QACjF,CAAC,CAAC;;MAEJ,OAAOgF,OAAO;IAChB,CAAC;IAEDnF,eAAA,CAAAyC,SAAA,CAAAqC,IAAI,GAAJ;MACE,IAAI,CAAC1B,IAAI,CAACC,IAAI,CAAC,UAAU,CAAC;MAC1B,IAAI,IAAI,CAAC7B,kCAAkC,EAAE;QAC3C,IAAI,CAACA,kCAAkC,EAAE;QACzC,IAAI,CAACA,kCAAkC,GAAG,IAAI;;MAEhD,OAAO,IAAI,CAACyC,KAAK,EAAE;IACrB,CAAC;IACH,OAAAjE,eAAC;EAAD,CAAC,CAlQoCH,iBAAiB;AAmQxD;AAEA;;;;;;AAMA,SAAS0C,+BAA+BA,CAAC8C,eAAe;EAEpD,IAAMlC,GAAG,GAGPkC,eAAe,CAAAjC,IAHR;IACTxC,IAAI,GAEFyE,eAAe,CAAAzE,IAFb;IACgBgB,iBAAiB,GACnCyD,eAAe,CAAA1D,kBADoB;EAGvC,IAAM2D,aAAa,GAAG;IACpB9B,KAAK,EAAElE,iBAAiB;IACxBmE,KAAK,EAAElE;GACR,CAACqB,IAAI,CAAC;EAEP,IAAM2E,yBAAyB,GAAG,SAAAA,CAAA;IAAM,OAAA3D,iBAAiB,GACrDA,iBAAiB,CAAC4D,WAAW,GAC7BH,eAAe,CAACpF,gBAAgB;EAFI,CAEJ;EAE9B,IAAU2E,EAAE,GAAKS,eAAe,CAAAI,QAApB;EAClB,IAAIxF,gBAAgB,GAAGsF,yBAAyB,EAAE;EAClD,IAAIG,qBAAqB,GAAG,IAAI;EAEhC,SAASC,YAAYA,CAAA;IACnB;IACA,OAAOf,EAAE,CAACgB,IAAI,EAAE,CAACjC,IAAI,CAAC;MAAM,OAAA2B,aAAa,CAACV,EAAE,CAAC;IAAjB,CAAiB,CAAC,CAACjB,IAAI,CAAC,UAAAkC,QAAQ;MAC1D,IAAIA,QAAQ,EAAE;QACZ1C,GAAG,CAACuB,IAAI,CAAC,kBAAkB,CAAC;OAC7B,MAAM;QACLvB,GAAG,CAACE,IAAI,CAAC,sBAAsB,CAAC;;MAElC,OAAOwC,QAAQ;IACjB,CAAC,CAAC,CAAC3B,KAAK,CAAC,UAAAC,KAAK;MACZhB,GAAG,CAACuB,IAAI,CAAC,2BAA2B,EAAEP,KAAK,CAAC;IAC9C,CAAC,CAAC,CAACiB,OAAO,CAAC;MACT;MACA,IAAI,CAACC,eAAe,CAACS,cAAc,EAAE;QACnClB,EAAE,CAACmB,KAAK,EAAE;;IAEd,CAAC,CAAC;EACJ;EAEA,SAASC,oBAAoBA,CAAA;IAEzB,IAAAxE,kCAAkC,GAEhC6D,eAAe,CAAA7D,kCAFiB;MAClCa,SAAS,GACPgD,eAAe,CAAAhD,SADR;IAGX,IAAM4D,sBAAsB,GAAG5D,SAAS,IAAI,CAAC,CAACb,kCAAkC;IACxE,IAAAY,KAAK,GAAKmD,yBAAyB,EAAE,CAAAnD,KAAhC;IAEb;IACA;IACA;IACA;IACA,OAAOmC,OAAO,CAACC,OAAO,EAAE,CAACb,IAAI,CAAC;MAC5B,OAAOtD,QAAQ,CAACE,eAAe,KAAK,SAAS,IACxC,CAACmF,qBAAqB,KACrBtD,KAAK,IAAI6D,sBAAsB,IAAIN,YAAY,EAAE,CAAC;IAC1D,CAAC,CAAC;EACJ;EAEA,SAASO,YAAYA,CAAA;IACnB,OAAO3B,OAAO,CAAC4B,IAAI,CAAC,CAClBhH,YAAY,CAACc,gBAAgB,EAAE,QAAQ,CAAC,EACxCf,eAAe,CAAC,EAAE,CAAC,CACpB,CAAC,CAACyE,IAAI,CAAC;MAAM,OAAAqC,oBAAoB,EAAE;IAAtB,CAAsB,CAAC,CAACrC,IAAI,CAAC,UAAAyC,eAAe;MACxD,IAAIA,eAAe,IAAI,CAACV,qBAAqB,EAAE;QAC7CA,qBAAqB,GAAGzG,KAAK,EAAE;QAC/BoG,eAAe,CAACrB,QAAQ,EAAE,CAACoB,OAAO,CAAC;UACjCR,EAAE,GAAGS,eAAe,CAACI,QAAQ;UAC7BY,+BAA+B,EAAE;UACjCpG,gBAAgB,GAAGsF,yBAAyB,EAAE;UAC9Ce,4BAA4B,EAAE;UAC9BZ,qBAAqB,CAAClB,OAAO,EAAE;UAC/BkB,qBAAqB,GAAG,IAAI;QAC9B,CAAC,CAAC,CAACxB,KAAK,CAAC,UAAAC,KAAK;UACZhB,GAAG,CAACgB,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;QAC/C,CAAC,CAAC;;MAGJ;MACA;MACA;MACA,IAAMgB,OAAO,GAAIO,qBAAqB,IAAIA,qBAAqB,CAACP,OAAO,IAAKZ,OAAO,CAACC,OAAO,EAAE;MAC7F,OAAOW,OAAO,CAACC,OAAO,CAAC;QAAM,OAAA3F,0BAA0B,CAAC8G,eAAe,CAAC3F,IAAI,CAAC;MAAhD,CAAgD,CAAC;IAChF,CAAC,CAAC,CAACsD,KAAK,CAAC,UAAAsC,EAAE;MACTrD,GAAG,CAACgB,KAAK,CAAC,4BAA0BqC,EAAE,CAACC,OAAS,CAAC;IACnD,CAAC,CAAC;EACJ;EAEA,SAASC,MAAMA,CAAA;IACL,IAAMvD,GAAG,GAAWkC,eAAe,CAAAjC,IAA1B;MAAExC,IAAI,GAAKyE,eAAe,CAAAzE,IAApB;IACvBuC,GAAG,CAACE,IAAI,CAAC,OAAO,CAAC;IACjBF,GAAG,CAACG,KAAK,CAAC,kBAAkB,EAAE+B,eAAe,CAAC;IAE9C;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA5F,0BAA0B,CAACkH,aAAa,CAAC/F,IAAI,CAAC;EAChD;EAEA,SAAS0F,4BAA4BA,CAAA;IACnC,IAAIrG,gBAAgB,CAACK,gBAAgB,EAAE;MACrCL,gBAAgB,CAACK,gBAAgB,CAAC,OAAO,EAAE4F,YAAY,CAAC;MACxDjG,gBAAgB,CAACK,gBAAgB,CAAC,MAAM,EAAEoG,MAAM,CAAC;MACjDzG,gBAAgB,CAACK,gBAAgB,CAAC,QAAQ,EAAE4F,YAAY,CAAC;KAC1D,MAAM;MACLjG,gBAAgB,CAAC2G,OAAO,GAAGV,YAAY;MACvCjG,gBAAgB,CAAC4G,MAAM,GAAGH,MAAM;MAChCzG,gBAAgB,CAAC6G,QAAQ,GAAGZ,YAAY;;EAE5C;EAEA,SAASG,+BAA+BA,CAAA;IACtC,IAAIpG,gBAAgB,CAAC8G,mBAAmB,EAAE;MACxC9G,gBAAgB,CAAC8G,mBAAmB,CAAC,OAAO,EAAEb,YAAY,CAAC;MAC3DjG,gBAAgB,CAAC8G,mBAAmB,CAAC,MAAM,EAAEL,MAAM,CAAC;MACpDzG,gBAAgB,CAAC8G,mBAAmB,CAAC,QAAQ,EAAEb,YAAY,CAAC;KAC7D,MAAM;MACLjG,gBAAgB,CAAC2G,OAAO,GAAG,IAAI;MAC/B3G,gBAAgB,CAAC4G,MAAM,GAAG,IAAI;MAC9B5G,gBAAgB,CAAC6G,QAAQ,GAAG,IAAI;;EAEpC;EAEA;EACA;EACA;EACA;EACA,IAAIE,kBAAkB,GAAG,SAAAA,CAAAC,SAAS;IAChC,OAAOA,SAAS,GAAGf,YAAY,EAAE,GAAG,KAAK;EAC3C,CAAC;EACD1G,yBAAyB,CAACwH,kBAAkB,CAAC,CAAC,EAAEA,kBAAkB,CAAC;EACnEV,4BAA4B,EAAE;EAE9B,OAAO;IACL9G,yBAAyB,CAAC0H,mBAAmB,CAAC,CAAC,EAAEF,kBAAkB,CAAC;IACpEX,+BAA+B,EAAE;EACnC,CAAC;AACH;AAEAc,MAAM,CAACC,OAAO,GAAGxH,oBAAoB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}